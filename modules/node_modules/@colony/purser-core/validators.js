"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bn_js_1 = __importDefault(require("bn.js"));
const utils_1 = require("./utils");
const messages_1 = require("./messages");
const defaults_1 = require("./defaults");
/**
 * Validate a derivation path passed in as a string
 *
 * @method derivationPathValidator
 *
 * @param {string} derivationPath The derivation path to check
 *
 * @return {boolean} It only returns true if the derivation path is correct,
 * otherwise an Error will be thrown and this will not finish execution.
 */
exports.derivationPathValidator = (derivationPath) => {
    const { derivationPath: derivationPathMessages } = messages_1.validators;
    const { COIN_MAINNET, COIN_TESTNET } = defaults_1.PATH;
    let deSerializedDerivationPath;
    let coinType;
    try {
        /*
         * Because assignments get bubbled to the top of the method, we need to wrap
         * this inside a try/catch block.
         *
         * Otherwise, this will fail before we have a change to assert it.
         */
        deSerializedDerivationPath = derivationPath.split(defaults_1.PATH.DELIMITER);
        coinType = parseInt(deSerializedDerivationPath[1], 10);
    }
    catch (caughtError) {
        throw new Error(`${derivationPathMessages.notString}: ${derivationPath || defaults_1.UNDEFINED}`);
    }
    /*
     * We need to assert this in a separate step, otherwise, if the size of the split
     * chunks is not correct the `match()` method call will fail before the
     * validator generator sequence will actually start.
     */
    utils_1.assertTruth({
        /*
         * It should be composed of (at least) four parts
         * (purpouse, coin, account, change and/or index)
         */
        expression: deSerializedDerivationPath.length === 4,
        message: [
            `${derivationPathMessages.notValidParts}: [`,
            ...deSerializedDerivationPath,
            ']',
        ],
        level: 'high'
    });
    const validationSequence = [
        {
            /*
             * It should have the correct Header Key (the letter 'm')
             */
            expression: deSerializedDerivationPath[0].split(defaults_1.SPLITTER)[0].toLowerCase() ===
                defaults_1.PATH.HEADER_KEY,
            message: [
                `${derivationPathMessages.notValidHeaderKey}:`,
                deSerializedDerivationPath[0] || defaults_1.UNDEFINED,
            ],
        },
        {
            /*
             * It should have the Ethereum reserved Purpouse (44)
             */
            expression: parseInt(deSerializedDerivationPath[0].split(defaults_1.SPLITTER)[1], 10) ===
                defaults_1.PATH.PURPOSE,
            message: [
                `${derivationPathMessages.notValidPurpouse}:`,
                deSerializedDerivationPath[0] || defaults_1.UNDEFINED,
            ],
        },
        {
            /*
             * It should have the correct Coin type
             */
            expression: coinType === COIN_MAINNET || coinType === COIN_TESTNET,
            message: [
                `${derivationPathMessages.notValidCoin}:`,
                deSerializedDerivationPath[1] || defaults_1.UNDEFINED,
            ],
        },
        {
            /*
             * It should have the correct Account format (eg: a number)
             */
            expression: !!deSerializedDerivationPath[2].match(defaults_1.MATCH.DIGITS),
            message: [
                `${derivationPathMessages.notValidAccount}:`,
                deSerializedDerivationPath[2] || defaults_1.UNDEFINED,
            ],
        },
        {
            /*
             * It should have the correct Change and/or Account Index format (eg: a number)
             */
            expression: deSerializedDerivationPath[3]
                .split(defaults_1.SPLITTER)
                .map(value => !!value.match(defaults_1.MATCH.DIGITS))
                .every(truth => truth !== false),
            message: [
                `${derivationPathMessages.notValidChangeIndex}:`,
                deSerializedDerivationPath[3] || defaults_1.UNDEFINED,
            ],
        },
        {
            /*
             * It should have the correct amount of Account Indexed (just one)
             */
            expression: deSerializedDerivationPath[3].split(defaults_1.SPLITTER).length <= 2,
            message: [
                `${derivationPathMessages.notValidAccountIndex}:`,
                deSerializedDerivationPath[3] || defaults_1.UNDEFINED,
            ],
        },
    ];
    return utils_1.validatorGenerator(validationSequence, `${derivationPathMessages.genericError}: ${derivationPath || defaults_1.UNDEFINED}`);
};
/**
 * Validate an integer passed in to make sure is safe (< 9007199254740991) and positive
 *
 * @method safeIntegerValidator
 *
 * @param {number} integer The integer to validate
 *
 * @return {boolean} It only returns true if the integer is safe and positive,
 * otherwise an Error will be thrown and this will not finish execution.
 */
exports.safeIntegerValidator = (integer) => {
    const { safeInteger: safeIntegerMessages } = messages_1.validators;
    const validationSequence = [
        {
            /*
             * It should be a number primitive
             */
            expression: typeof integer === 'number',
            message: `${safeIntegerMessages.notNumber}: ${integer}`,
        },
        {
            /*
             * It should be a positive number
             * This is a little less trutfull as integers can also be negative
             */
            expression: integer >= 0,
            message: `${safeIntegerMessages.notPositive}: ${integer}`,
        },
        {
            /*
             * It should be under the safe integer limit: Â± 9007199254740991
             * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger
             */
            expression: Number.isSafeInteger(integer),
            message: `${safeIntegerMessages.notSafe}: ${integer}`,
        },
    ];
    return utils_1.validatorGenerator(validationSequence, `${safeIntegerMessages.genericError}: ${integer}`);
};
/**
 * Validate a Big Number instance object that was passed in
 *
 * @method bigNumberValidator
 *
 * @param {Object} bigNumber The big number instance to check
 *
 * @return {boolean} It only returns true if the object is an instance of Big Number,
 * otherwise an Error will be thrown and this will not finish execution.
 */
exports.bigNumberValidator = (bigNumber) => {
    const { bigNumber: bigNumberMessages } = messages_1.validators;
    const validationSequence = [
        {
            /*
             * It should be an instance of the BN Class
             */
            expression: bn_js_1.default.isBN(bigNumber),
            message: `${bigNumberMessages.notBigNumber}: ${utils_1.objectToErrorString(bigNumber)}`,
        },
    ];
    return utils_1.validatorGenerator(validationSequence, `${bigNumberMessages.genericError}: ${utils_1.objectToErrorString(bigNumber)}`);
};
/**
 * Validate a BIP32 Ethereum Address
 *
 * @TODO Validate the checksum of the address.
 *
 * @method addressValidator
 *
 * @param {string} address The 'hex' address to check
 *
 * @return {boolean} It only returns true if the string is a valid address format,
 * otherwise an Error will be thrown and this will not finish execution.
 */
exports.addressValidator = (address) => {
    const { address: addressMessages } = messages_1.validators;
    let addressLength = 0;
    try {
        /*
         * Because length checking is bubbled to the top, we need to to wrap this inside
         * a separate try-catch block, otherwise the whole thing will fail before the
         * validation sequence will even start.
         */
        addressLength = address.length;
    }
    catch (caughtError) {
        throw new Error(`${addressMessages.notStringSequence}: ${defaults_1.UNDEFINED}`);
    }
    const validationSequence = [
        {
            /*
            * It should be a string
            */
            expression: typeof address === 'string',
            message: `${addressMessages.notStringSequence}: ${utils_1.objectToErrorString(address) || defaults_1.UNDEFINED}`,
        },
        {
            /*
            * It should be the correct length. Either 40 or 42 (with prefix)
            */
            expression: addressLength === 40 || addressLength === 42,
            message: `${addressMessages.notLength}: ${address || defaults_1.UNDEFINED}`,
        },
        {
            /*
             * It should be in the correct format (hex string of length 40 with or
             * with out the `0x` prefix)
             */
            expression: !!address.match(defaults_1.MATCH.ADDRESS),
            message: `${addressMessages.notFormat}: ${address || defaults_1.UNDEFINED}`,
        },
    ];
    return utils_1.validatorGenerator(validationSequence, `${addressMessages.genericError}: ${address || defaults_1.UNDEFINED}`);
};
/**
 * Validate a hex string
 *
 * @method hexSequenceValidator
 *
 * @param {string} hexSequence The `hex` string to check
 *
 * @return {boolean} It only returns true if the string is a valid hex format,
 * otherwise an Error will be thrown and this will not finish execution.
 */
exports.hexSequenceValidator = (hexSequence) => {
    const { hexSequence: hexSequenceMessages } = messages_1.validators;
    const validationSequence = [
        {
            /*
            * It should be a string
            */
            expression: typeof hexSequence === 'string',
            message: `${hexSequenceMessages.notStringSequence}: ${utils_1.objectToErrorString(hexSequence) || defaults_1.UNDEFINED}`,
        },
        {
            /*
            * It should be in the correct format (hex string with or with out the `0x` prefix)
            */
            expression: !!hexSequence.match(defaults_1.MATCH.HEX_STRING),
            message: `${hexSequenceMessages.notFormat}: ${hexSequence || defaults_1.UNDEFINED}`,
        },
    ];
    return utils_1.validatorGenerator(validationSequence, `${hexSequenceMessages.genericError}: ${hexSequence || defaults_1.UNDEFINED}`);
};
/**
 * Validate a hex string
 *
 * @method messageValidator
 *
 * @param {string} string The big number instance to check
 *
 * @return {boolean} It only returns true if the string is a valid format,
 * otherwise an Error will be thrown and this will not finish execution.
 */
exports.messageValidator = (string) => {
    /*
     * Real creative naming there, huh...?
     */
    const { message: messageMessages } = messages_1.validators;
    const validationSequence = [
        {
            /*
            * It should be a string
            */
            expression: typeof string === 'string',
            message: `${messageMessages.notString}: ${utils_1.objectToErrorString(string) ||
                defaults_1.UNDEFINED}`,
        },
        {
            /*
            * It should be under (or equal to) 1024 Bytes in size
            */
            expression: string.length <= 1024,
            message: `${messageMessages.tooBig}: ${string || defaults_1.UNDEFINED}`,
        },
    ];
    return utils_1.validatorGenerator(validationSequence, `${messageMessages.genericError}: ${string || defaults_1.UNDEFINED}`);
};
/**
 * Validate a hex string
 *
 * @method messageDataValidator
 *
 * @param {any} data The messageData to check
 *
 * @return {boolean} It only returns true if the data is a valid format,
 * otherwise an Error will be thrown and this will not finish execution.
 */
exports.messageDataValidator = (data) => {
    const { message: messageMessages } = messages_1.validators;
    const validationSequence = [
        {
            /*
            * It should be a hex string or UInt8Array
            */
            expression: (typeof data === 'string' && exports.hexSequenceValidator(data)) ||
                data.constructor === Uint8Array,
            message: `${messageMessages.notString}: ${utils_1.objectToErrorString(data) ||
                defaults_1.UNDEFINED}`,
        },
    ];
    return utils_1.validatorGenerator(validationSequence, `${messageMessages.genericError}: ${data || defaults_1.UNDEFINED}`);
};
