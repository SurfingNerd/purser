"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const hdkey_1 = __importDefault(require("hdkey"));
const validators_1 = require("./validators");
const normalizers_1 = require("./normalizers");
const messages_1 = require("./messages");
const defaults_1 = require("./defaults");
const types_1 = require("./types");
//const { GETTERS, SETTERS, WALLET_PROPS, GENERIC_PROPS } = DESCRIPTORS;
/*
 * "Private" (internal) variable(s).
 *
 * These are used as return values from getters which don't have an accompanying setter,
 * but we still want to set them internally.
 */
let internalPublicKey;
let internalDerivationPath;
/*
 * @TODO Support extra props
 *
 * Support the extra props required for the software wallet (privateKey, mnemonic, etc...)
 * Also, we need to find a way to extend both this and the `ethers` wallet class
 */
class GenericWallet {
    constructor({ publicKey, chainCode, rootDerivationPath, addressCount = 10, chainId = defaults_1.CHAIN_IDS.HOMESTEAD, }) {
        /*
         * Validate address count (this comes from the end user)
         */
        validators_1.safeIntegerValidator(addressCount);
        /*
         * Validate the `publicKey` and `chainCode` hex sequences. These come from
         * various external services, and we shouldn't trust them.
         */
        validators_1.hexSequenceValidator(publicKey);
        validators_1.hexSequenceValidator(chainCode);
        chainCode;
        /*
         * Derive the public key with the address index, so we can get the address
         */
        const hdKey = new hdkey_1.default();
        hdKey.publicKey = Buffer.from(publicKey, defaults_1.HEX_HASH_TYPE);
        /*
         * Sadly Flow doesn't have the correct types for node's Buffer Object
         */
        /* $FlowFixMe */
        hdKey.chainCode = Buffer.from(chainCode, defaults_1.HEX_HASH_TYPE);
        const otherAddresses = Array.from(
        /*
         * We default to `1`, but this time, to prevent the case where the
         * user passes in the value `0` manually (which will break the array map)
         */
        new Array(addressCount || 1), (value, index) => {
            //const addressObject : GenericClassArgumentsType = {};
            const derivationKey = hdKey.deriveChild(index);
            /*
             * Set this individual address's derivation path
             */
            const addressObject_derivationPath = rootDerivationPath.substr(-1) === defaults_1.SPLITTER
                ? `${rootDerivationPath}${index}`
                : `${rootDerivationPath}${defaults_1.SPLITTER}${index}`;
            /*
             * This is the derrived public key, not the one originally fetched one
             */
            const derivedPublicKey = derivationKey.publicKey.toString(defaults_1.HEX_HASH_TYPE);
            const addressObject_publicKey = normalizers_1.hexSequenceNormalizer(derivedPublicKey);
            /*
             * Generate the address from the derived public key
             */
            const addressFromPublicKey = utils_1.computeAddress(
            /*
             * Sadly Flow doesn't have the correct types for node's Buffer Object
             */
            /* $FlowFixMe */
            derivationKey.publicKey);
            /*
             * Also validate the address that comes from the `HDKey` library.
             */
            validators_1.addressValidator(addressFromPublicKey);
            const addressObject = { publicKey: addressObject_publicKey,
                derivationPath: addressObject_derivationPath,
                address: normalizers_1.addressNormalizer(addressFromPublicKey)
            };
            return addressObject;
        });
        /*
         * Set the "private" (internal) variables values
         */
        internalPublicKey = otherAddresses[0].publicKey;
        internalDerivationPath = otherAddresses[0].derivationPath;
        /*
         * Set the Wallet Object's values
         *
         * We're using `defineProperties` instead of strait up assignment, so that
         * we can customize the prop's descriptors
         *
         * @TODO Reduce code repetition when setting Class props
         *
         * We do this here and in the software wallet, so it might make sense to
         * write a helper method for this.
         */
        Object.defineProperties(this, {
            address: Object.assign({}, { value: otherAddresses[0].address }, defaults_1.DESCRIPTORS.SETTERS),
            chainId: Object.assign({}, { value: chainId }, defaults_1.DESCRIPTORS.WALLET_PROPS),
            type: Object.assign({}, { value: types_1.TYPE_GENERIC }, defaults_1.DESCRIPTORS.GENERIC_PROPS),
            subtype: Object.assign({}, { value: types_1.SUBTYPE_GENERIC }, defaults_1.DESCRIPTORS.GENERIC_PROPS),
            /**
             * Set the default address/public key/path one of the (other) addresses from the array.
             * This is usefull since most methods (sign, signMessage) use this props as defaults.
             *
             * There's an argument to be made here that we can derive new addresses only when this
             * method gets called.
             *
             * This would be helpful to offload the initial cost of deriving a number
             * of `addressCount` addresses.
             *
             * On the other hand, if we do this, we won't be able to show the user what
             * addresses are available up front.
             *
             * @method setDefaultAddress
             *
             * @param {number} addressIndex The address index from the array
             *
             * @return {Promise<boolean>} True if it was able to set it, false otherwise
             */
            setDefaultAddress: Object.assign({}, {
                /*
                 * @TODO Accept both number and object as argument
                 * To make the arguments consistent across the wallet instance methods
                 */
                value: (addressIndex = 0) => __awaiter(this, void 0, void 0, function* () {
                    validators_1.safeIntegerValidator(addressIndex);
                    if (addressIndex >= 0 && addressIndex < otherAddresses.length) {
                        /*
                         * Address count will always be at least `1` (the first derived address).
                         *
                         * This method is useful (can be used) only when the user generated more than
                         * one address when instantiating the Wallet.
                         */
                        this.address = otherAddresses[addressIndex].address;
                        internalPublicKey = otherAddresses[addressIndex].publicKey;
                        internalDerivationPath =
                            otherAddresses[addressIndex].derivationPath;
                        return true;
                    }
                    throw new Error(`${messages_1.genericClass.addressIndexOutsideRange}: index (${addressIndex}) count (${addressCount})`);
                }),
            }, defaults_1.DESCRIPTORS.WALLET_PROPS),
            /*
             * These are just a placeholder static methods. They should be replaced (or deleted at least)
             * with methods that actually has some functionality.
             */
            sign: Object.assign({}, { value: () => __awaiter(this, void 0, void 0, function* () { }) }, defaults_1.DESCRIPTORS.GENERIC_PROPS),
            signMessage: Object.assign({}, { value: () => __awaiter(this, void 0, void 0, function* () { }) }, defaults_1.DESCRIPTORS.GENERIC_PROPS),
            verifyMessage: Object.assign({}, { value: () => __awaiter(this, void 0, void 0, function* () { }) }, defaults_1.DESCRIPTORS.GENERIC_PROPS),
        });
        /*
         * The `otherAddresses` prop is only available if we have more than one.
         *
         * Otherwise it's pointless since it just repeats information (first index
         * is also the default one).
        */
        if (addressCount > 1) {
            Object.defineProperty(this, 'otherAddresses', Object.assign({}, {
                /*
                 * Map out the publicKey and derivation path from the `otherAddresses`
                 * array that gets assigned to the Wallet instance.
                 *
          * The user should only have access to `the publicKey` and `derivationPath` from the
                 * default account (set via `setDefaultAddress()`)
                 */
                value: otherAddresses.map(({ address }) => address),
            }, defaults_1.DESCRIPTORS.WALLET_PROPS));
        }
    }
    /*
     * Public Key Getter
     */
    /* eslint-disable-next-line class-methods-use-this */
    get publicKey() {
        return Promise.resolve(internalPublicKey);
    }
    /* eslint-disable-next-line class-methods-use-this */
    get derivationPath() {
        return Promise.resolve(internalDerivationPath);
    }
}
exports.default = GenericWallet;
/*
 * We need to use `defineProperties` to make props enumerable.
 * When adding them via a `Class` getter/setter it will prevent that by default
 */
/*
Object.defineProperties((GenericWallet: any).prototype, {
  publicKey: GETTERS,
  derivationPath: GETTERS,
});
*/
