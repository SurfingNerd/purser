import { TransactionOptions } from 'ethereumjs-tx';
import { DerivationPathObjectType, MessageVerificationObjectType, TransactionObjectTypeWithTo } from './types';
/**
 * Serialize an derivation path object's props into it's string counterpart
 *
 * @method derivationPathSerializer
 *
 * @param {number} purpose path purpose
 * @param {number} coinType path coin type (and network)
 * @param {number} account path account number
 * @param {number} change path change number
 * @param {number} addressIndex address index (no default since it should be manually added)
 *
 * See the defaults file for some more information regarding the format of the
 * Ethereum deviation path.
 *
 * All the above params are sent in as props of an {DerivationPathObjectType} object.
 *
 * @return {string} The serialized path
 */
export declare const derivationPathSerializer: ({ purpose, coinType, account, change, addressIndex, }?: DerivationPathObjectType) => string;
/**
 * Recover a public key from a message and the signature of that message.
 *
 * @NOTE Further optimization
 *
 * This can be further optimized by writing our own recovery mechanism since we already
 * do most of the cleanup, checking and coversions.
 *
 * All that is left to do is to use `secp256k1` to convert and recover the public key
 * from the signature points (components).
 *
 * But since most of our dependencies already use `ethereumjs-util` under the hood anyway,
 * it's easier just use it as well.
 *
 * @method recoverPublicKey
 *
 * @param {string} message The message string to hash for the signature verification procedure
 * @param {string} signature The signature to recover the private key from, as a `hex` string
 *
 * All the above params are sent in as props of an {MessageVerificationObjectType} object.
 *
 * @return {String} The recovered public key.
 */
export declare const recoverPublicKey: ({ message, signature }: MessageVerificationObjectType) => string;
/**
 * Verify a signed message.
 * By extracting it's public key from the signature and comparing it with a provided one.
 *
 * @method verifyMessageSignature
 *
 * @param {string} publicKey Public key to check against, as a 'hex' string
 * @param {string} message The message string to hash for the signature verification procedure
 * @param {string} signature The signature to recover the private key from, as a `hex` string
 *
 * All the above params are sent in as props of an {MessageVerificationObjectType} object.
 *
 * @return {boolean} true or false depending if the signature is valid or not
 *
 */
export declare const verifyMessageSignature: ({ publicKey, message, signature, }: {
    publicKey: any;
    message: any;
    signature: any;
}) => boolean;
/**
 * Validate an transaction object
 *
 * @NOTE We can only validate here, we can't also normalize. This is because different
 * wallet types expect different value formats so we must normalize them on a case by case basis.
 *
 * @method transactionObjectValidator
 *
 * @param {bigNumber} gasPrice gas price for the transaction in WEI (as an instance of bigNumber), defaults to 9000000000 (9 GWEI)
 * @param {bigNumber} gasLimit gas limit for the transaction (as an instance of bigNumber), defaults to 21000
 * @param {number} chainId the id of the chain for which this transaction is intended. Defaults to 1
 * @param {number} nonce the nonce to use for the transaction (as a number)
 * @param {string} to the address to which to the transaction is sent
 * @param {bigNumber} value the value of the transaction in WEI (as an instance of bigNumber), defaults to 1
 * @param {string} inputData data appended to the transaction (as a `hex` string)
 *
 * All the above params are sent in as props of an {TransactionObjectType} object.
 *
 * @return {TransactionObjectType} The validated transaction object containing the exact passed in values
 */
export declare const transactionObjectValidator: ({ gasPrice, gasLimit, chainId, nonce, to, value, inputData, }?: TransactionObjectTypeWithTo) => TransactionObjectTypeWithTo;
/**
 * Validate a signature verification message object
 *
 * @method messageVerificationObjectValidator
 *
 * @param {string} message The message string to check the signature against
 * @param {string} signature The signature of the message.
 *
 * All the above params are sent in as props of an {MessageVerificationObjectType} object.
 *
 * @return {Object} The validated signature object containing the exact passed in values
 */
export declare const messageVerificationObjectValidator: ({ message, signature, }: MessageVerificationObjectType) => MessageVerificationObjectType;
/**
 * Check if the user provided input is in the form of an Object and it's required props
 *
 * @method userInputValidator
 *
 * @param {Object} firstArgument The argument to validate that it's indeed an object, and that it has the required props
 * @param {Array} requiredEither Array of strings representing prop names of which at least one is required.
 * @param {Array} requiredAll Array of strings representing prop names of which all are required.
 *
 * All the above params are sent in as props of an object.
 */
export declare const userInputValidator: ({ firstArgument, requiredEither, requiredAll, requiredOr, }?: {
    firstArgument?: Object;
    requiredEither?: String[];
    requiredAll?: String[];
    requiredOr?: String[];
}) => void;
export declare const messageOrDataValidator: ({ message, messageData }: {
    message: any;
    messageData: any;
}) => string | Uint8Array;
/**
 * In order to support EIP-155, it's necessary to specify various
 * definitions for a given chain (e.g. the chain ID, network ID, hardforks).
 *
 * Given a chain ID, this function returns a chain definition in the format
 * expected by `ethereumjs-tx`.
 *
 * @param {number} chainId The given chain ID (as defined in EIP-155)
 * @return {Object} The common chain definition
 */
export declare const getChainDefinition: (chainId: number) => TransactionOptions;
declare const coreHelpers: {
    getChainDefinition: (chainId: number) => TransactionOptions;
    derivationPathSerializer: ({ purpose, coinType, account, change, addressIndex, }?: DerivationPathObjectType) => string;
    recoverPublicKey: ({ message, signature }: MessageVerificationObjectType) => string;
    verifyMessageSignature: ({ publicKey, message, signature, }: {
        publicKey: any;
        message: any;
        signature: any;
    }) => boolean;
    transactionObjectValidator: ({ gasPrice, gasLimit, chainId, nonce, to, value, inputData, }?: TransactionObjectTypeWithTo) => TransactionObjectTypeWithTo;
    messageVerificationObjectValidator: ({ message, signature, }: MessageVerificationObjectType) => MessageVerificationObjectType;
    userInputValidator: ({ firstArgument, requiredEither, requiredAll, requiredOr, }?: {
        firstArgument?: Object;
        requiredEither?: String[];
        requiredAll?: String[];
        requiredOr?: String[];
    }) => void;
    messageOrDataValidator: ({ message, messageData }: {
        message: any;
        messageData: any;
    }) => string | Uint8Array;
};
export default coreHelpers;
