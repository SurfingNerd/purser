"use strict";
/* @flow */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const secret_storage_1 = require("ethers/utils/secret-storage");
const ethereumjs_util_1 = require("ethereumjs-util");
const helpers_1 = require("../purser-core/helpers");
const utils_1 = require("../purser-core/utils");
const normalizers_1 = require("../purser-core/normalizers");
const validators_1 = require("../purser-core/validators");
const defaults_1 = require("../purser-core/defaults");
const types_1 = require("../purser-core/types");
const staticMethods_1 = require("./staticMethods");
const messages_1 = require("./messages");
const { GETTERS, WALLET_PROPS } = defaults_1.DESCRIPTORS;
/*
 * "Private" (internal) variable(s)
 */
let internalKeystoreJson;
let internalEncryptionPassword;
/**
 * @NOTE We're no longer directly extending the Ethers Wallet Class
 *
 * This is due to the fact that we need more control over the resulting Class
 * object (SoftwareWallet in this case).
 *
 * We're still shadowing the Ethers Wallet, meaning when opening or creating a new
 * wallet, we will first create a Ethers Wallet instance than pass that along
 * to the SoftwareWallet constructor.
 *
 * This way we don't have to deal with non-configurable or non-writable props,
 * or the providers being baked in.
 */
class SoftwareWallet {
    constructor(ethersInstance) {
        const { address, privateKey, password, originalMnemonic: mnemonic, keystore, chainId, sign: ethersSign, signMessage: ethersSignMessage, } = ethersInstance;
        /*
         * Validate the private key and address that's coming in from ethers.
         */
        validators_1.addressValidator(address);
        validators_1.hexSequenceValidator(privateKey);
        /*
         * If we have a keystore JSON string and encryption password, set them
         * to the internal variables.
         */
        internalEncryptionPassword = password;
        internalKeystoreJson = keystore;
        /*
         * Set the private key to a "internal" variable since we only allow
         * access to it through a getter and not directly via a prop.
         */
        Object.defineProperties(this, {
            address: Object.assign({}, { value: address }, WALLET_PROPS),
            type: Object.assign({}, { value: types_1.TYPE_SOFTWARE }, WALLET_PROPS),
            subtype: Object.assign({}, { value: types_1.SUBTYPE_ETHERS }, WALLET_PROPS),
            chainId: Object.assign({}, { value: chainId }, WALLET_PROPS),
            /*
             * Getters
             */
            privateKey: Object.assign({}, { get: () => __awaiter(this, void 0, void 0, function* () { return privateKey; }) }, GETTERS),
            /*
             * @TODO Allow users control of the derivation path
             * When instantiating a new class instance. But this is only if the feature
             * turns out to be required.
             */
            derivationPath: Object.assign({}, {
                get: () => __awaiter(this, void 0, void 0, function* () {
                    return helpers_1.derivationPathSerializer({
                        change: defaults_1.PATH.CHANGE,
                        addressIndex: defaults_1.PATH.INDEX,
                    });
                }),
            }, GETTERS),
            sign: Object.assign({}, {
                value: (transactionObject) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: transactionObject,
                    });
                    const { chainId: transactionChainId = this.chainId } = transactionObject || {};
                    const callbackToUse = ethersSign.bind(ethersInstance);
                    return staticMethods_1.signTransaction(Object.assign({}, transactionObject, {
                        chainId: transactionChainId,
                        /*
                         * @NOTE We need to bind the whole ethers instance
                         *
                         * Since the `sign` will look for different methods inside the
                         * class's prototype, and if it fails to find them, it will
                         * crash
                         */
                        callback: callbackToUse,
                    }));
                }),
            }, WALLET_PROPS),
            signMessage: Object.assign({}, {
                value: (messageObject) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: messageObject,
                        requiredOr: defaults_1.REQUIRED_PROPS.SIGN_MESSAGE,
                    });
                    return staticMethods_1.signMessage({
                        message: messageObject.message,
                        messageData: messageObject.messageData,
                        /*
                         * @NOTE We need to bind the whole ethers instance
                         *
                         * Since the `signMessage` will look for different methods inside the
                         * class's prototype, and if it fails to find them, it will
                         * crash
                         */
                        callback: ethersSignMessage.bind(ethersInstance),
                    });
                }),
            }, WALLET_PROPS),
            verifyMessage: Object.assign({}, {
                value: (signatureVerificationObject) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: signatureVerificationObject,
                        requiredAll: defaults_1.REQUIRED_PROPS.VERIFY_MESSAGE,
                    });
                    const { message, signature } = signatureVerificationObject;
                    return staticMethods_1.verifyMessage({
                        address,
                        message,
                        signature,
                    });
                }),
            }, WALLET_PROPS),
        });
        /*
         * Only set the `mnemonic` prop if it's available, so it won't show up
         * as being defined, but set to `undefined`
         */
        if (mnemonic) {
            Object.defineProperty(this, 'mnemonic', Object.assign({}, { get: () => __awaiter(this, void 0, void 0, function* () { return mnemonic; }) }, GETTERS));
        }
    }
    get keystore() {
        /*
         * We're wrapping the getter (returning actually) in a IIFE so we can
         * write it using a `async` pattern.
         */
        return (() => __awaiter(this, void 0, void 0, function* () {
            if (internalEncryptionPassword) {
                const privateKey = yield this.privateKey;
                /*
                 * Memoizing the getter
                 *
                 * This is quite an expensive operation, so we're memoizing it that
                 * on the next call (an the others after that) it won't re-calculate
                 * the value again.
                 */
                Object.defineProperty(this, 'keystore', Object.assign({}, GETTERS, {
                    value: (internalKeystoreJson && Promise.resolve(internalKeystoreJson)) ||
                        /*
                         * We're usign Ethers's direct secret storage encrypt method to generate
                         * the keystore JSON string
                         *
                         * @TODO Validate the password
                         *
                         * The password won't work if it's not a string, so it will be best if
                         * we write a string validator for it
                         */
                        secret_storage_1.encrypt(privateKey, internalEncryptionPassword.toString()),
                }));
                return ((internalKeystoreJson && Promise.resolve(internalKeystoreJson)) ||
                    /*
                     * We're usign Ethers's direct secret storage encrypt method to generate
                     * the keystore JSON string
                     *
                     * @TODO Validate the password
                     *
                     * The password won't work if it's not a string, so it will be best if
                     * we write a string validator for it
                     */
                    secret_storage_1.encrypt(privateKey, internalEncryptionPassword.toString()));
            }
            utils_1.warning(messages_1.walletClass.noPassword);
            return Promise.reject();
        }))();
    }
    /*
     * Just set the encryption password, we don't return anything from here,
     * hence we don't have a need for `this`.
     *
     * This is just an convenince to allow us to set the encryption password
     * after the wallet has be created / instantiated.
     */
    /* eslint-disable-next-line class-methods-use-this */
    //set keystore(newEncryptionPassword: string): void {
    //  internalEncryptionPassword = newEncryptionPassword;
    //}
    get publicKey() {
        /*
         * We're wrapping the getter (returning actually) in a IIFE so we can
         * write it using a `async` pattern.
         */
        return (() => __awaiter(this, void 0, void 0, function* () {
            const privateKey = yield this.privateKey;
            const privateKeyBuffer = Buffer.from(privateKey, defaults_1.HEX_HASH_TYPE);
            const publicKeyBuffer = ethereumjs_util_1.privateToPublic(privateKeyBuffer);
            let reversedPublicKey = publicKeyBuffer.toString(defaults_1.HEX_HASH_TYPE);
            /*
             * Validate the reversed public key
             */
            validators_1.hexSequenceValidator(reversedPublicKey);
            /*
             * Then normalize it to ensure it has the `0x` prefix
             */
            const normalizedPublicKey = normalizers_1.hexSequenceNormalizer(reversedPublicKey);
            console.log('const normalizedPublicKey: string = hexSequenceNormalizer(');
            /*
             * Memoizing the getter
             *
             * While this is not an expensive operation, it's still a good idea
             * to memoize it so it returns a tiny bit faster.
             */
            Object.defineProperty(this, 'publicKey', Object.assign({}, GETTERS, {
                value: Promise.resolve(normalizedPublicKey),
            }));
            return normalizedPublicKey;
        }))();
    }
}
exports.default = SoftwareWallet;
/*
 * We need to use `defineProperties` to make props enumerable.
 * When adding them via a `Class` getter/setter it will prevent that by default
 */
Object.defineProperties(SoftwareWallet.prototype, {
    publicKey: GETTERS,
    keystore: GETTERS,
});
