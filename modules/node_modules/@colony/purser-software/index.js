"use strict";
/* @flow */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const wallet_1 = require("ethers/wallet");
const hdnode_1 = require("ethers/utils/hdnode");
const json_wallet_1 = require("ethers/utils/json-wallet");
const helpers_1 = require("../purser-core/helpers");
const utils_1 = require("../purser-core/utils");
const defaults_1 = require("../purser-core/defaults");
const class_1 = __importDefault(require("./class"));
const defaults_2 = require("./defaults");
const messages_1 = require("./messages");
/**
 * Open an existing wallet
 * Using either `mnemonic`, `private key` or `encrypted keystore`
 *
 * This will try to extract the private key from a mnemonic (if available),
 * and create a new SoftwareWallet instance using whichever key is available.
 * (the on passed in or the one extracted from the mnemonic).
 *
 * @TODO Reduce code repetition
 *
 * With some clever refactoring we might be able to only call the SoftwareWallet
 * constructor a single time for all three methods of opening the wallet
 *
 * @method open
 *
 * @param {string} password Optional password used to generate an encrypted keystore
 * @param {string} privateKey Private key to open the wallet with
 * @param {string} mnemonic Mnemonic string to open the wallet with
 * @param {string} keystore JSON formatted keystore string to open the wallet with.
 * Only works if you also send in a password
 * @param {number} chainId The id of the network to use, defaults to mainnet (1)
 *
 * All the above params are sent in as props of an {WalletArgumentsType} object.
 *
 * @return {WalletType} A new wallet object (or undefined) if somehwere along
 * the line an error is thrown.
 */
exports.open = (argumentObject = {}) => __awaiter(void 0, void 0, void 0, function* () {
    /*
     * Validate the trasaction's object input
     */
    helpers_1.userInputValidator({
        firstArgument: argumentObject,
        requiredEither: defaults_2.REQUIRED_PROPS.OPEN_WALLET,
    });
    const { password, privateKey, mnemonic, keystore, chainId = defaults_1.CHAIN_IDS.HOMESTEAD, } = argumentObject;
    let extractedPrivateKey;
    /*
     * @TODO Re-add use ability to control derivation path
     * When opening the wallet. But only if this proves to be a needed feature.
     */
    const derivationPath = helpers_1.derivationPathSerializer({
        change: defaults_1.PATH.CHANGE,
        addressIndex: defaults_1.PATH.INDEX,
    });
    try {
        /*
         * @TODO Detect if existing but not valid keystore, and warn the user
         */
        if (keystore && json_wallet_1.isSecretStorageWallet(keystore) && password) {
            const keystoreWallet = 
            /*
             * Prettier suggests changes that would always result in eslint
             * breaking. This must be one of the edge cases of prettier.
             *
             * Nevertheless, by inserting this comment, it works :)
             */
            yield wallet_1.Wallet.fromEncryptedJson(keystore, password);
            /*
             * Set the keystore and password props on the instance object.
             *
             * So that we can make use of them inside the SoftwareWallet
             * constructor, as the Ethers Wallet instance object will
             * be passed down.
             *
             * @TODO Better passing of values
             *
             * This needs to be refactored to pass values to the SoftwareWallet
             * class in a less repetitious way
             */
            const walletArgs = keystoreWallet;
            walletArgs.keystore = keystore;
            walletArgs.password = password;
            walletArgs.chainId = chainId;
            return new class_1.default(walletArgs);
        }
        /*
         * @TODO Detect if existing but not valid mnemonic, and warn the user
         */
        if (mnemonic && hdnode_1.isValidMnemonic(mnemonic)) {
            const mnemonicWallet = hdnode_1.fromMnemonic(mnemonic).derivePath(derivationPath);
            extractedPrivateKey = mnemonicWallet.privateKey;
        }
        /*
         * @TODO Detect if existing but not valid private key, and warn the user
         */
        const privateKeyWallet = new wallet_1.Wallet(privateKey || extractedPrivateKey);
        const walletArguments = {};
        walletArguments.privateKey = privateKeyWallet.privateKey;
        walletArguments.address = privateKeyWallet.address;
        walletArguments.privateKey = privateKey || extractedPrivateKey;
        /*
         * Set the mnemonic and password props on the instance object.
         *
         * So that we can make use of them inside the SoftwareWallet
         * constructor, as the Ethers Wallet instance object will
         * be passed down.
         *
         * @TODO Better passing of values
         *
         * This needs to be refactored to pass values to the SoftwareWallet
         * class in a less repetitious way
         */
        walletArguments.password = password;
        walletArguments.chainId = chainId;
        /*
         * @NOTE mnemonic prop was renamed due to naming conflict with getter-only
         * ethers prop
         */
        walletArguments.originalMnemonic = mnemonic;
        return new class_1.default(walletArguments);
    }
    catch (caughtError) {
        throw new Error(`${messages_1.staticMethods.open} ${utils_1.objectToErrorString({
            password,
            privateKey,
            mnemonic,
            keystore,
        })} Error: ${caughtError.message}`);
    }
});
/**
 * Create a new wallet.
 *
 * This will use EtherWallet's `createRandom()` (with defaults and entropy)
 * and use the resulting private key to instantiate a new SoftwareWallet.
 *
 * @method create
 *
 * @param {Uint8Array} entropy An unsigned 8bit integer Array to provide extra randomness
 * @param {string} password Optional password used to generate an encrypted keystore
 * @param {number} chainId The id of the network to use, defaults to mainnet (1)
 *
 * All the above params are sent in as props of an {WalletArgumentsType} object.
 *
 * @return {WalletType} A new wallet object
 */
exports.create = (argumentObject = {}) => __awaiter(void 0, void 0, void 0, function* () {
    /*
     * Validate the trasaction's object input
     */
    helpers_1.userInputValidator({
        firstArgument: argumentObject,
    });
    const { password, entropy = utils_1.getRandomValues(new Uint8Array(65536)), chainId = defaults_1.CHAIN_IDS.HOMESTEAD, } = argumentObject;
    let basicWallet;
    try {
        if (!entropy || (entropy && !(entropy instanceof Uint8Array))) {
            utils_1.warning(messages_1.staticMethods.noEntrophy);
            basicWallet = wallet_1.Wallet.createRandom();
        }
        else {
            basicWallet = wallet_1.Wallet.createRandom({
                extraEntropy: entropy,
            });
        }
        /*
         * Set the password prop on the instance object.
         *
         * So that we can make use of them inside the SoftwareWallet
         * constructor, as the Ethers Wallet instance object will
         * be passed down.
         *
         * @TODO Better passing of values
         *
         * This needs to be refactored to pass values to the SoftwareWallet
         * class in a less repetitious way
         */
        basicWallet.password = password;
        basicWallet.chainId = chainId;
        /*
         * @NOTE mnemonic prop was renamed due to naming conflict with getter-only
         * ethers prop
         */
        basicWallet.originalMnemonic = basicWallet.mnemonic;
        return new class_1.default(basicWallet);
    }
    catch (caughtError) {
        throw new Error(`${messages_1.staticMethods.create} Error: ${caughtError.message}`);
    }
});
const softwareWallet = {
    open: exports.open,
    create: exports.create,
};
exports.default = softwareWallet;
