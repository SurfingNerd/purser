"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("ethers/utils");
const helpers_1 = require("../purser-core/helpers");
const normalizers_1 = require("../purser-core/normalizers");
const validators_1 = require("../purser-core/validators");
const utils_2 = require("../purser-core/utils");
const messages_1 = require("./messages");
/**
 * Sign a transaction object and return the serialized signature (as a hex string)
 *
 * @method signTransaction
 *
 * @param {bigNumber} gasPrice gas price for the transaction in WEI (as an instance of bigNumber), defaults to 9000000000 (9 GWEI)
 * @param {bigNumber} gasLimit gas limit for the transaction (as an instance of bigNumber), defaults to 21000
 * @param {number} chainId the id of the chain for which this transaction is intended
 * @param {number} nonce the nonce to use for the transaction (as a number)
 * @param {string} to the address to which to the transaction is sent
 * @param {bigNumber} value the value of the transaction in WEI (as an instance of bigNumber), defaults to 1
 * @param {string} inputData data appended to the transaction (as a `hex` string)
 * @param {function} callback Ethers method to call with the validated transaction object
 *
 * All the above params are sent in as props of an {TransactionObjectType} object.
 *
 * @return {Promise<string>} the hex signature string
 */
exports.signTransaction = (transactionObject) => __awaiter(void 0, void 0, void 0, function* () {
    const { gasPrice, gasLimit, chainId, nonce, to, value, inputData, } = helpers_1.transactionObjectValidator(transactionObject);
    try {
        const signedTransaction = yield transactionObject.callback(Object.assign({}, {
            /*
             * Ethers needs it's own "proprietary" version of bignumber to work.
             */
            gasPrice: utils_1.bigNumberify(gasPrice.toString()),
            /*
             * Ethers needs it's own "proprietary" version of bignumber to work.
             */
            gasLimit: utils_1.bigNumberify(gasLimit.toString()),
            chainId,
            nonce,
            /*
             * Ethers needs it's own "proprietary" version of bignumber to work.
             */
            value: utils_1.bigNumberify(value.toString()),
            data: normalizers_1.hexSequenceNormalizer(inputData),
        }, 
        /*
         * Only send (and normalize) the destination address if one was
         * provided in the initial transaction object.
         */
        to ? { to: normalizers_1.addressNormalizer(to) } : {}));
        return normalizers_1.hexSequenceNormalizer(signedTransaction);
    }
    catch (caughtError) {
        throw new Error(`${messages_1.staticMethods.cannotSign} ${utils_2.objectToErrorString({
            gasPrice,
            gasLimit,
            chainId,
            nonce,
            to,
            value,
            inputData,
        })} Error: ${caughtError.message}`);
    }
});
/**
 * Sign a message and return the signature. Useful for verifying identities.
 *
 * @method signMessage
 *
 * @param {string} message the message you want to sign
 * @param {string} messageData the message you want to sign
 * @param {function} callback Ethers method to call with the validated message string
 *
 * All the above params are sent in as props of an {object}. Note that only one
 * of message or messageData can be set (enforced in class).
 *
 * @return {Promise<string>} The signed message `hex` string (wrapped inside a `Promise`)
 */
exports.signMessage = (obj) => __awaiter(void 0, void 0, void 0, function* () {
    const { message, messageData, callback } = obj;
    /*
     * Validate input value
     */
    const toSign = helpers_1.messageOrDataValidator({ message, messageData });
    try {
        const messageSignature = yield callback(toSign);
        /*
         * Normalize the message signature
         */
        return normalizers_1.hexSequenceNormalizer(messageSignature);
    }
    catch (caughtError) {
        throw new Error(`${messages_1.staticMethods.cannotSignMessage}: ${message} Error: ${caughtError.message}`);
    }
});
/**
 * Verify a signed message. Useful for verifying identity. (In conjunction with `signMessage`)
 *
 * @method verifyMessage
 *
 * @param {string} address The wallet address to verify the signature against
 * @param {string} message The message to verify if it was signed correctly
 * @param {string} signature The message signature as a `hex` string (you usually get this via `signMessage`)
 *
 * All the above params are sent in as props of an {MessageVerificationObjectType} object.
 *
 * @return {Promise<boolean>} A boolean to indicate if the message/signature pair are valid (wrapped inside a `Promise`)
 */
exports.verifyMessage = (signatureMessage) => __awaiter(void 0, void 0, void 0, function* () {
    const { address } = signatureMessage;
    /*
     * Validate the address locally
     */
    validators_1.addressValidator(address);
    /*
     * Validate the rest of the pros using the core helper
     */
    const { message, signature } = helpers_1.messageVerificationObjectValidator(signatureMessage);
    try {
        const recoveredAddress = utils_1.verifyMessage(message, signature);
        /*
         * Validate the recovered address
         */
        validators_1.addressValidator(recoveredAddress);
        return address === recoveredAddress;
    }
    catch (caughtError) {
        throw new Error(`${messages_1.staticMethods.cannotVerifySignature} ${utils_2.objectToErrorString(signatureMessage)} Error: ${caughtError.message}`);
    }
});
