"use strict";
/* @flow */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bip32_path_1 = require("bip32-path");
const ethereumjs_tx_1 = require("ethereumjs-tx");
const validators_1 = require("@colony/purser-core/validators");
const normalizers_1 = require("@colony/purser-core/normalizers");
const utils_1 = require("@colony/purser-core/utils");
const helpers_1 = require("@colony/purser-core/helpers");
const defaults_1 = require("@colony/purser-core/defaults");
const helpers_2 = require("./helpers");
const messages_1 = require("./messages");
const defaults_2 = require("./defaults");
const payloads_1 = require("./payloads");
/**
 * Sign a transaction object and return the serialized signature (as a hex string)
 *
 * @method signTransaction
 *
 * @param {string} derivationPath the derivation path for the account with which to sign the transaction
 * @param {bigNumber} gasPrice gas price for the transaction in WEI (as an instance of bigNumber), defaults to 9000000000 (9 GWEI)
 * @param {bigNumber} gasLimit gas limit for the transaction (as an instance of bigNumber), defaults to 21000
 * @param {number} chainId the id of the chain for which this transaction is intended
 * @param {number} nonce the nonce to use for the transaction (as a number)
 * @param {string} to the address to which to the transaction is sent
 * @param {bigNumber} value the value of the transaction in WEI (as an instance of bigNumber), defaults to 1
 * @param {string} inputData data appended to the transaction (as a `hex` string)
 *
 * All the above params are sent in as props of an {TransactionObjectType} object.
 *
 * @return {Promise<string>} the hex signature string
 */
exports.signTransaction = (_a = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var { derivationPath } = _a, transactionObject = __rest(_a, ["derivationPath"]);
    const { gasPrice, gasLimit, chainId, nonce, to, value, inputData, } = helpers_1.transactionObjectValidator(transactionObject);
    validators_1.derivationPathValidator(derivationPath);
    /*
     * @TODO Reduce code repetition
     *
     * Between the unsigned EthereumTx signature object values and the values
     * sent to the Trezor server
     */
    const unsignedTransaction = new ethereumjs_tx_1.Transaction({
        /*
         * We could really do with some BN.js flow types declarations :(
         */
        gasPrice: normalizers_1.hexSequenceNormalizer(
        /*
         * @TODO Add `bigNumber` `toHexString` wrapper method
         *
         * Flow confuses bigNumber's `toString` with the String object
         * prototype `toString` method
         */
        /* $FlowFixMe */
        normalizers_1.multipleOfTwoHexValueNormalizer(gasPrice.toString(16))),
        gasLimit: normalizers_1.hexSequenceNormalizer(
        /*
         * @TODO Add `bigNumber` `toHexString` wrapper method
         *
         * Flow confuses bigNumber's `toString` with the String object
         * prototype `toString` method
         */
        /* $FlowFixMe */
        normalizers_1.multipleOfTwoHexValueNormalizer(gasLimit.toString(16))),
        /*
         * Nonces needs to be sent in as a hex string, and to be padded as a multiple of two.
         * Eg: '3' to be '03', `12c` to be `012c`
         */
        nonce: normalizers_1.hexSequenceNormalizer(
        /*
         * @TODO Add `bigNumber` `toHexString` wrapper method
         *
         * Flow confuses bigNumber's `toString` with the String object
         * prototype `toString` method
         */
        /* $FlowFixMe */
        normalizers_1.multipleOfTwoHexValueNormalizer(nonce.toString(16))),
        value: normalizers_1.hexSequenceNormalizer(
        /*
         * @TODO Add `bigNumber` `toHexString` wrapper method
         *
         * Flow confuses bigNumber's `toString` with the String object
         * prototype `toString` method
         */
        /* $FlowFixMe */
        normalizers_1.multipleOfTwoHexValueNormalizer(value.toString(16))),
        data: normalizers_1.hexSequenceNormalizer(inputData),
        /*
         * The transaction object needs to be seeded with the (R) and (S) signature components with
         * empty data, and the Reco(V)ery param as the chain id (all, im hex string format).
         *
         * See this issue for context:
         * https://github.com/LedgerHQ/ledgerjs/issues/43
         */
        r: normalizers_1.hexSequenceNormalizer(normalizers_1.multipleOfTwoHexValueNormalizer(String(defaults_1.SIGNATURE.R))),
        s: normalizers_1.hexSequenceNormalizer(normalizers_1.multipleOfTwoHexValueNormalizer(String(defaults_1.SIGNATURE.S))),
        v: normalizers_1.hexSequenceNormalizer(
        /*
         * @TODO Add `bigNumber` `toHexString` wrapper method
         *
         * Flow confuses bigNumber's `toString` with the String object
         * prototype `toString` method
         */
        /* $FlowFixMe */
        normalizers_1.multipleOfTwoHexValueNormalizer(chainId.toString(16))),
    }, helpers_1.getChainDefinition(chainId));
    /*
     * Modify the default payload to set the transaction details
     */
    const modifiedPayloadObject = Object.assign({}, payloads_1.PAYLOAD_SIGNTX, {
        /*
         * Path needs to be sent in as an derivation path array
         */
        address_n: bip32_path_1.fromString(normalizers_1.derivationPathNormalizer(derivationPath), true).toPathArray(),
        /*
         * @TODO Add `bigNumber` `toHexString` wrapper method
         *
         * Flow confuses bigNumber's `toString` with the String object
         * prototype `toString` method
         */
        /* $FlowFixMe */
        gas_price: normalizers_1.multipleOfTwoHexValueNormalizer(gasPrice.toString(16)),
        /*
         * @TODO Add `bigNumber` `toHexString` wrapper method
         *
         * Flow confuses bigNumber's `toString` with the String object
         * prototype `toString` method
         */
        /* $FlowFixMe */
        gas_limit: normalizers_1.multipleOfTwoHexValueNormalizer(gasLimit.toString(16)),
        chain_id: chainId,
        /*
         * Nonces needs to be sent in as a hex string, and to be padded as a multiple of two.
         * Eg: '3' to be '03', `12c` to be `012c`
         *
         * @TODO Add `bigNumber` `toHexString` wrapper method
         *
         * Flow confuses bigNumber's `toString` with the String object
         * prototype `toString` method
         */
        /* $FlowFixMe */
        nonce: normalizers_1.multipleOfTwoHexValueNormalizer(nonce.toString(16)),
        /*
         * @TODO Add `bigNumber` `toHexString` wrapper method
         *
         * Flow confuses bigNumber's `toString` with the String object
         * prototype `toString` method
         */
        /* $FlowFixMe */
        value: normalizers_1.multipleOfTwoHexValueNormalizer(value.toString(16)),
        /*
         * Trezor service requires the prefix from the input data to be stripped
         */
        data: normalizers_1.hexSequenceNormalizer(inputData, false),
    }, 
    /*
     * Only send (and normalize) the destingation address if one was
     * provided in the initial transaction object.
     *
     * Trezor service requires the prefix from the address to be stripped
     */
    to ? { to: normalizers_1.addressNormalizer(to, false) } : {});
    /*
     * We need to catch the cancelled error since it's part of a normal user workflow
     */
    try {
        /*
         * See fundamentals of Elliptic Curve Digital Signature Algorithm (ECDSA) to
         * get an general idea of where the three components come from:
         * https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm
         *
         * Also, see EIP-155 for the 27 and 28 magic numbers expected in the recovery
         * parameter:
         * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
         *
         * Now, trezor will give you the recovery paramenter already encoded, but if you
         * want to derive the magic numbers again:
         *
         * recoveryParam - 35 - (chainId * 2)
         *
         * If the result is odd, then V is 27, if it's even, it's 28
         */
        const { r: rSignatureComponent, s: sSignatureComponent, v: recoveryParameter, } = yield helpers_2.payloadListener({ payload: modifiedPayloadObject });
        /*
         * Add the signature values to the unsigned trasaction
         */
        unsignedTransaction.r = normalizers_1.hexSequenceNormalizer(rSignatureComponent);
        unsignedTransaction.s = normalizers_1.hexSequenceNormalizer(sSignatureComponent);
        unsignedTransaction.v = normalizers_1.hexSequenceNormalizer(utils_1.bigNumber(recoveryParameter).toString(16));
        return normalizers_1.hexSequenceNormalizer(unsignedTransaction.serialize().toString(defaults_1.HEX_HASH_TYPE));
    }
    catch (caughtError) {
        /*
         * If the user cancels signing the transaction we still throw,
         * but we customize the message.
         */
        if (caughtError.message === defaults_2.STD_ERRORS.CANCEL_TX_SIGN) {
            throw new Error(messages_1.staticMethods.userSignTxCancel);
        }
        /*
         * But throw otherwise, so we can see what's going on
         */
        throw new Error(`${messages_1.staticMethods.userSignTxGenericError}: ${utils_1.objectToErrorString(modifiedPayloadObject)} ${caughtError.message}`);
    }
});
/**
 * Sign a message and return the signature. Useful for verifying addresses.
 * (In conjunction with `verifyMessage`)
 *
 * @method signMessage
 *
 * @param {string} derivationPath the derivation path for the account with which to sign the message
 * @param {string} message the message you want to sign
 * @param {string} messageData the message data you want to sign
 *
 * All the above params are sent in as props of an object.
 *
 * @return {Promise<string>} The signed message `hex` string (wrapped inside a `Promise`)
 */
exports.signMessage = ({ derivationPath, message, messageData, } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    /*
     * Validate input values: derivationPath and message
     */
    validators_1.derivationPathValidator(derivationPath);
    const toSign = helpers_1.messageOrDataValidator({ message, messageData });
    utils_1.warning(messages_1.staticMethods.messageSignatureOnlyTrezor);
    try {
        const { signature: signedMessage = '' } = yield helpers_2.payloadListener({
            payload: Object.assign({}, payloads_1.PAYLOAD_SIGNMSG, {
                /*
                 * Path needs to be sent in as an derivation path array
                 *
                 * We also normalize it first (but for some reason Flow doesn't pick up
                 * the default value value of `path` and assumes it's undefined -- it can be,
                 * but it will not pass the validator)
                 */
                path: bip32_path_1.fromString(normalizers_1.derivationPathNormalizer(derivationPath), true).toPathArray(),
                // $FlowFixMe need Buffer types
                message: Buffer.from(toSign).toString(defaults_1.HEX_HASH_TYPE),
            }),
        });
        /*
         * Add the hex `0x` prefix
         */
        return normalizers_1.hexSequenceNormalizer(signedMessage);
    }
    catch (caughtError) {
        /*
         * If the user cancels signing the message we still throw,
         * but we customize the message
         */
        if (caughtError.message === defaults_2.STD_ERRORS.CANCEL_TX_SIGN) {
            throw new Error(messages_1.staticMethods.userSignTxCancel);
        }
        /*
         * But throw otherwise, so we can see what's going on
         */
        throw new Error(`${messages_1.staticMethods.userSignTxGenericError}: message: (${message}) ${caughtError.message}`);
    }
});
/**
 * Verify a signed message. Useful for verifying addresses. (In conjunction with `signMessage`)
 *
 * @method verifyMessage
 *
 * @param {string} address The address that verified the original message (without the hex `0x` identifier)
 * @param {string} message The message to verify if it was signed correctly
 * @param {string} signature The message signature as a `hex` string (you usually get this via `signMessage`)
 *
 * All the above params are sent in as props of an {MessageObjectType} object.
 *
 * @return {Promise<boolean>} A boolean to indicate if the message/signature pair are valid (wrapped inside a `Promise`)
 */
exports.verifyMessage = (_b = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var { address } = _b, signatureMessage = __rest(_b, ["address"]);
    /*
     * Validate the address locally
     */
    validators_1.addressValidator(address);
    /*
     * Validate the rest of the pros using the core helper
     */
    const { message, signature } = helpers_1.messageVerificationObjectValidator(signatureMessage);
    utils_1.warning(messages_1.staticMethods.messageSignatureOnlyTrezor);
    try {
        const { success: isMessageValid } = yield helpers_2.payloadListener({
            payload: Object.assign({}, payloads_1.PAYLOAD_VERIFYMSG, {
                /*
                 * Trezor service requires the prefix from the address to be stripped
                 */
                address: normalizers_1.addressNormalizer(address, false),
                message,
                /*
                 * Trezor service requires the prefix from the signature to be stripped
                 */
                signature: normalizers_1.hexSequenceNormalizer(signature, false),
            }),
        });
        return isMessageValid;
    }
    catch (caughtError) {
        utils_1.warning(`${messages_1.staticMethods.messageSignatureInvalid}: message (${message}), signature (${signature})`);
        return false;
    }
});
