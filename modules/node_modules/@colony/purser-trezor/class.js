"use strict";
/* @flow */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const genericWallet_1 = __importDefault(require("@colony/purser-core/genericWallet"));
const helpers_1 = require("@colony/purser-core/helpers");
const utils_1 = require("@colony/purser-core/utils");
const defaults_1 = require("@colony/purser-core/defaults");
const types_1 = require("@colony/purser-core/types");
const staticMethods_1 = require("./staticMethods");
const messages_1 = require("./messages");
const defaults_2 = require("./defaults");
const { WALLET_PROPS } = defaults_1.DESCRIPTORS;
class TrezorWallet extends genericWallet_1.default {
    constructor(propObject) {
        super(propObject);
        Object.defineProperties(this, {
            /*
             * Set the actual type and subtype (overwrite the generic ones)
             */
            type: Object.assign({}, { value: types_1.TYPE_HARDWARE }, WALLET_PROPS),
            subtype: Object.assign({}, { value: types_1.SUBTYPE_TREZOR }, WALLET_PROPS),
            sign: Object.assign({}, {
                value: (transactionObject) => __awaiter(this, void 0, void 0, function* () {
                    let requiredSignProps = defaults_2.REQUIRED_PROPS.SIGN_TRANSACTION;
                    const { chainId = this.chainId, to } = transactionObject || {};
                    /*
                     * If we don't have a destination address, it means the user wants
                     * to deploy a contract.
                     *
                     * For this the Trezor service requires a `inputData` value set.
                     *
                     * Otherwise, a `to` address *must* be set.
                     */
                    if (!to) {
                        requiredSignProps =
                            defaults_2.REQUIRED_PROPS.SIGN_TRANSACTION_CONTRACT;
                        /*
                         * Warn the user (in dev mode, at least) about Trezor's contract
                         * deployment requirements
                         */
                        utils_1.warning(messages_1.classInstance.signContractDeployment);
                    }
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: transactionObject,
                        requiredAll: requiredSignProps,
                    });
                    return staticMethods_1.signTransaction(Object.assign({}, transactionObject, {
                        derivationPath: yield this.derivationPath,
                        chainId,
                    }));
                }),
            }, WALLET_PROPS),
            signMessage: Object.assign({}, {
                value: (messageObject = {}) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: messageObject,
                        requiredOr: defaults_1.REQUIRED_PROPS.SIGN_MESSAGE,
                    });
                    return staticMethods_1.signMessage({
                        derivationPath: yield this.derivationPath,
                        message: messageObject.message,
                        messageData: messageObject.messageData,
                    });
                }),
            }, WALLET_PROPS),
            verifyMessage: Object.assign({}, {
                value: (signatureVerificationObject = {}) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: signatureVerificationObject,
                        requiredAll: defaults_1.REQUIRED_PROPS.VERIFY_MESSAGE,
                    });
                    const { message, signature } = signatureVerificationObject;
                    return staticMethods_1.verifyMessage({
                        address: this.address,
                        message,
                        signature,
                    });
                }),
            }, WALLET_PROPS),
        });
    }
}
exports.default = TrezorWallet;
