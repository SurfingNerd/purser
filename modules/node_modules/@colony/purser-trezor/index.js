"use strict";
/* @flow */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bip32_path_1 = require("bip32-path");
const helpers_1 = require("../purser-core/helpers");
const utils_1 = require("../purser-core/utils");
const defaults_1 = require("../purser-core/defaults");
const class_1 = __importDefault(require("./class"));
const helpers_2 = require("./helpers");
const messages_1 = require("./messages");
const defaults_2 = require("./defaults");
const payloads_1 = require("./payloads");
/**
 * Open a new wallet from the public key and chain code, which are received
 * form the Trezor service after interacting (confirming) with the hardware
 * in real life.
 *
 * @method open
 *
 * @param {number} addressCount the number of extra addresses to generate from the derivation path
 * @param {number} chainId The id of the network to use, defaults to mainnet (1)
 *
 * The above param is sent in as a prop of an {WalletArgumentsType} object.
 *
 * @return {WalletType} The wallet object resulted by instantiating the class
 * (Object is wrapped in a promise).
 *
 */
exports.open = (argumentObject = {}) => __awaiter(void 0, void 0, void 0, function* () {
    /*
     * Validate the trasaction's object input
     */
    helpers_1.userInputValidator({
        firstArgument: argumentObject,
    });
    const { addressCount, chainId = defaults_1.CHAIN_IDS.HOMESTEAD } = argumentObject;
    /*
     * @TODO Reduce code repetition
     * By moving this inside a helper. This same patter will be used on the
     * ledger wallet as well.
     *
     * If we're on a testnet set the coin type id to `1`
     * This will be used in the derivation path
     */
    const coinType = chainId === defaults_1.CHAIN_IDS.HOMESTEAD ? defaults_1.PATH.COIN_MAINNET : defaults_1.PATH.COIN_TESTNET;
    /*
     * Get to root derivation path based on the coin type.
     *
     * Based on this, we will then derive all the needed address indexes
     * (inside the class constructor)
     */
    const rootDerivationPath = helpers_1.derivationPathSerializer({
        change: defaults_1.PATH.CHANGE,
        coinType,
    });
    /*
     * Modify the default payload to overwrite the path with the new
     * coin type id derivation
     */
    const modifiedPayloadObject = Object.assign({}, payloads_1.PAYLOAD_XPUB, {
        path: bip32_path_1.fromString(rootDerivationPath, true).toPathArray(),
    });
    /*
     * We need to catch the cancelled error since it's part of a normal user workflow
     */
    try {
        /*
         * Get the harware wallet's public key and chain code, to use for deriving
         * the rest of the accounts
         */
        const { publicKey, chainCode } = yield helpers_2.payloadListener({
            payload: modifiedPayloadObject.path,
        });
        const walletInstance = new class_1.default({
            publicKey,
            chainCode,
            rootDerivationPath,
            addressCount,
            chainId,
        });
        return walletInstance;
    }
    catch (caughtError) {
        /*
         * Don't throw an error if the user cancelled
         */
        if (caughtError.message === defaults_2.STD_ERRORS.CANCEL_ACC_EXPORT) {
            return utils_1.warning(messages_1.staticMethods.userExportCancel);
        }
        /*
         * But throw otherwise, so we can see what's going on
         */
        throw new Error(
        /*
         * @TODO Move message to general
         *
         * Right now this message string is added under the "static methods" category.
         * Since this is used in multiple places, there's a case to be made about
         * making it a "general" category message.
         */
        `${messages_1.staticMethods.userExportGenericError}: ${utils_1.objectToErrorString(modifiedPayloadObject)} ${caughtError.message}`);
    }
});
const trezorWallet = {
    open: exports.open,
};
exports.default = trezorWallet;
