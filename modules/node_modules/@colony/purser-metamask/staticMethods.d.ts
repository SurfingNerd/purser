import { Web3TransactionType } from './types';
import { TransactionObjectTypeWithAddresses } from "../purser-core/types";
/**
 * Get a transaction, with a workaround for some providers not returning
 * a pending transaction.
 *
 * If the transaction was not immediately returned, it's possible that
 * Infura is being used, and it isn't responding to `eth_getTransaction`
 * in the expected way (i.e. it isn't returning anything because the
 * transaction is not yet confirmed).
 *
 * This method uses a web3 0.20.x-compatible means of waiting for the
 * transaction to be confirmed (which will resolve to the receipt,
 * or reject if the transaction could not be confirmed.
 *
 * This can probably be removed when MetaMask has its own workaround.
 * See https://github.com/MetaMask/metamask-extension/issues/6704
 */
export declare const getTransaction: (transactionHash: string) => Promise<Web3TransactionType>;
export declare const signTransactionCallback: (chainId: number, resolve: (string: any) => void, reject: (Error: any) => void) => (error: Error, transactionHash: string) => Promise<void>;
/**
 * Sign (and send) a transaction object and return the serialized signature (as a hex string)
 *
 * @TODO Refactor to only sign the transaction
 * This is only after Metamask will allow us that functionality (see below)
 *
 * Metamask doesn't currently allow us to sign a transaction without also broadcasting it to
 * the network. See this issue for context:
 * https://github.com/MetaMask/metamask-extension/issues/3475
 *
 * @method signTransaction
 *
 * @param {string} from the sender address (provided by the Wallet instance)
 * @param {bigNumber} gasPrice gas price for the transaction in WEI (as an instance of bigNumber), defaults to 9000000000 (9 GWEI)
 * @param {bigNumber} gasLimit gas limit for the transaction (as an instance of bigNumber), defaults to 21000
 * @param {number} nonce the nonce to use for the transaction (as a number)
 * @param {string} to the address to which to the transaction is sent
 * @param {bigNumber} value the value of the transaction in WEI (as an instance of bigNumber), defaults to 1
 * @param {string} inputData data appended to the transaction (as a `hex` string)
 *
 * All the above params are sent in as props of an object.
 *
 * @return {Promise<string>} the hex signature string
 */
export declare const signTransaction: (obj: TransactionObjectTypeWithAddresses) => Promise<string | void>;
export declare const signMessageCallback: (resolve: (string: any) => void, reject: (Error: any) => void) => (error: Error, messageSignature: string) => void;
/**
 * Sign a message and return the signature. Useful for verifying identities.
 *
 * @method signMessage
 *
 * @param {string} currentAddress The current selected address (in the UI)
 * @param {string} message the message you want to sign
 * @param {any} messageData the message data (hex string or UInt8Array) you want to sign
 *
 * All the above params are sent in as props of an {object.
 *
 * @return {Promise<string>} The signed message `hex` string (wrapped inside a `Promise`)
 */
export declare const signMessage: (obj: {
    currentAddress: string;
    message: string;
    messageData: any;
}) => Promise<string | void>;
export declare const verifyMessageCallback: (currentAddress: string, resolve: (boolean: any) => void, reject: (Error: any) => void) => (error: Error, recoveredAddress: string) => void;
/**
 * Verify a signed message. Useful for verifying identity. (In conjunction with `signMessage`)
 *
 * @method verifyMessage
 *
 * @param {string} message The message to verify if it was signed correctly
 * @param {string} signature The message signature as a `hex` string (you usually get this via `signMessage`)
 * @param {string} currentAddress The current selected address (in the UI)
 *
 * All the above params are sent in as props of an object.
 *
 * @return {Promise<boolean>} A boolean to indicate if the message/signature pair are valid (wrapped inside a `Promise`)
 */
export declare const verifyMessage: (obj: {
    message: string;
    signature: string;
    currentAddress: string;
}) => Promise<any>;
