"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_tx_1 = require("ethereumjs-tx");
const bn_js_1 = __importDefault(require("bn.js"));
const await_transaction_mined_1 = require("await-transaction-mined");
const validators_1 = require("../purser-core/validators");
const normalizers_1 = require("../purser-core/normalizers");
const helpers_1 = require("../purser-core/helpers");
const defaults_1 = require("../purser-core/defaults");
const helpers_2 = require("./helpers");
const methodLinks_1 = require("./methodLinks");
const defaults_2 = require("./defaults");
const messages_1 = require("./messages");
/**
 * Get a transaction, with a workaround for some providers not returning
 * a pending transaction.
 *
 * If the transaction was not immediately returned, it's possible that
 * Infura is being used, and it isn't responding to `eth_getTransaction`
 * in the expected way (i.e. it isn't returning anything because the
 * transaction is not yet confirmed).
 *
 * This method uses a web3 0.20.x-compatible means of waiting for the
 * transaction to be confirmed (which will resolve to the receipt,
 * or reject if the transaction could not be confirmed.
 *
 * This can probably be removed when MetaMask has its own workaround.
 * See https://github.com/MetaMask/metamask-extension/issues/6704
 */
exports.getTransaction = (transactionHash) => __awaiter(void 0, void 0, void 0, function* () {
    const receiptPromise = await_transaction_mined_1.awaitTx(global.web3, transactionHash, {
        blocksToWait: 1,
    });
    const transaction = yield methodLinks_1.getTransaction(transactionHash);
    if (transaction) {
        return transaction;
    }
    yield receiptPromise;
    return methodLinks_1.getTransaction(transactionHash);
});
exports.signTransactionCallback = (chainId, resolve, reject) => (error, transactionHash) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        if (error) {
            /*
             * If the user cancels signing the transaction we still throw,
             * but we customize the message.
             */
            if (error.message.includes(defaults_2.STD_ERRORS.CANCEL_TX_SIGN)) {
                throw new Error(messages_1.staticMethods.cancelTransactionSign);
            }
            throw new Error(error.message);
        }
        /*
         * Validate that the signature hash is in the correct format
         */
        validators_1.hexSequenceValidator(transactionHash);
        /*
         * Add the `0x` prefix to the signed transaction hash
         */
        const normalizedTransactionHash = normalizers_1.hexSequenceNormalizer(transactionHash);
        /*
         * Get signed transaction object with transaction hash using Web3
         * Include signature + any values MetaMask may have changed.
         */
        const { gas, gasPrice: signedGasPrice, input: signedData, nonce, r, s, to: signedTo, v, value: signedValue, } = yield exports.getTransaction(normalizedTransactionHash);
        /*
         * RLP encode (to hex string) with ethereumjs-tx, prefix with
         * `0x` and return. Convert to BN all the numbers-as-strings.
         */
        const signedTransaction = new ethereumjs_tx_1.Transaction({
            data: signedData,
            gasLimit: new bn_js_1.default(gas),
            gasPrice: new bn_js_1.default(signedGasPrice),
            nonce: new bn_js_1.default(nonce),
            r,
            s,
            to: signedTo,
            v,
            value: new bn_js_1.default(signedValue),
        }, 
        //new class implements TransactionOptions {}
        helpers_1.getChainDefinition(chainId));
        const to = {};
        const serializedSignedTransaction = signedTransaction
            .serialize()
            .toString(defaults_1.HEX_HASH_TYPE);
        const normalizedSignedTransaction = normalizers_1.hexSequenceNormalizer(serializedSignedTransaction);
        return resolve(normalizedSignedTransaction);
    }
    catch (caughtError) {
        return reject(caughtError);
    }
});
/**
 * Sign (and send) a transaction object and return the serialized signature (as a hex string)
 *
 * @TODO Refactor to only sign the transaction
 * This is only after Metamask will allow us that functionality (see below)
 *
 * Metamask doesn't currently allow us to sign a transaction without also broadcasting it to
 * the network. See this issue for context:
 * https://github.com/MetaMask/metamask-extension/issues/3475
 *
 * @method signTransaction
 *
 * @param {string} from the sender address (provided by the Wallet instance)
 * @param {bigNumber} gasPrice gas price for the transaction in WEI (as an instance of bigNumber), defaults to 9000000000 (9 GWEI)
 * @param {bigNumber} gasLimit gas limit for the transaction (as an instance of bigNumber), defaults to 21000
 * @param {number} nonce the nonce to use for the transaction (as a number)
 * @param {string} to the address to which to the transaction is sent
 * @param {bigNumber} value the value of the transaction in WEI (as an instance of bigNumber), defaults to 1
 * @param {string} inputData data appended to the transaction (as a `hex` string)
 *
 * All the above params are sent in as props of an object.
 *
 * @return {Promise<string>} the hex signature string
 */
exports.signTransaction = (transactionObject) => __awaiter(void 0, void 0, void 0, function* () {
    const { from, chainId, gasPrice, gasLimit, to, value, inputData, } = helpers_1.transactionObjectValidator(transactionObject);
    validators_1.addressValidator(from);
    /*
     * Metamask auto-sets the nonce based on the next one available. You can manually
     * override it, but it's best to omit it.
     *
     * So we only validate if there is one, otherwise we just pass undefined
     * to the transaction object.
     *
     * We also notify (in dev mode) the user about not setting the nonce.
     */
    //TODO: fix manualNonce
    /*if (manualNonce) {
      safeIntegerValidator(manualNonce);
      warning(messages.dontSetNonce);
    }*/
    /*
     * We must check for the Metamask injected in-page proxy every time we
     * try to access it. This is because something can change it from the time
     * of last detection until now.
     */
    return helpers_2.methodCaller(
    /*
     * @TODO Move into own (non-anonymous) method
     * This way we could better test it
     */
    () => new Promise((resolve, reject) => methodLinks_1.signTransaction(Object.assign({}, {
        from: normalizers_1.addressNormalizer(from),
        /*
        * We don't need to normalize these three values since Metamask accepts
        * number values directly, so we don't need to convert them to hex
        */
        value: value.toString(),
        gas: gasLimit.toString(),
        gasPrice: gasPrice.toString(),
        data: normalizers_1.hexSequenceNormalizer(inputData),
        chainId,
        /*
         * Most likely this value is `undefined`, but that is good (see above)
         */
        nonce: manualNonce,
    }, 
    /*
     * Only send (and normalize) the destination address if one was
     * provided in the initial transaction object.
     */
    to ? { to: normalizers_1.addressNormalizer(to) } : {}), exports.signTransactionCallback(chainId, resolve, reject))), messages_1.staticMethods.cannotSendTransaction);
});
exports.signMessageCallback = (resolve) => void ;
(error, messageSignature) => {
    try {
        if (error) {
            /*
             * If the user cancels signing the message we still throw,
             * but we customize the message
             */
            if (error.message.includes(defaults_2.STD_ERRORS.CANCEL_MSG_SIGN)) {
                throw new Error(messages_1.staticMethods.cancelMessageSign);
            }
            throw new Error(error.message);
        }
        /*
         * Validate that the signature is in the correct format
         */
        validators_1.hexSequenceValidator(messageSignature);
        /*
         * Add the `0x` prefix to the message's signature
         */
        const normalizedSignature = normalizers_1.hexSequenceNormalizer(messageSignature);
        return resolve(normalizedSignature);
    }
    catch (caughtError) {
        return exports.reject(caughtError);
    }
};
/**
 * Sign a message and return the signature. Useful for verifying identities.
 *
 * @method signMessage
 *
 * @param {string} currentAddress The current selected address (in the UI)
 * @param {string} message the message you want to sign
 * @param {any} messageData the message data (hex string or UInt8Array) you want to sign
 *
 * All the above params are sent in as props of an {object.
 *
 * @return {Promise<string>} The signed message `hex` string (wrapped inside a `Promise`)
 */
exports.signMessage = ({ currentAddress, message, messageData, } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    validators_1.addressValidator(currentAddress);
    const toSign = helpers_1.messageOrDataValidator({ message, messageData });
    /*
     * We must check for the Metamask injected in-page proxy every time we
     * try to access it. This is because something can change it from the time
     * of last detection until now.
     */
    return helpers_2.methodCaller(
    /*
     * @TODO Move into own (non-anonymous) method
     * This way we could better test it
     */
    () => new Promise((resolve, reject) => {
        /*
         * Sign the message. This will prompt the user via Metamask's UI
         */
        methodLinks_1.signMessage(
        /*
         * Ensure the hex string has the `0x` prefix
         */
        normalizers_1.hexSequenceNormalizer(
        /*
         * We could really do with default Flow types for Buffer...
         */
        /* $FlowFixMe */
        Buffer.from(toSign).toString(defaults_1.HEX_HASH_TYPE)), currentAddress, exports.signMessageCallback(resolve, reject));
    }), messages_1.staticMethods.cannotSignMessage);
});
exports.verifyMessageCallback = (currentAddress, resolve, reject) => (error, recoveredAddress) => {
    try {
        if (error) {
            throw new Error(error.message);
        }
        /*
         * Validate that the recovered address is correct
         */
        validators_1.addressValidator(recoveredAddress);
        /*
         * Add the `0x` prefix to the recovered address
         */
        const normalizedRecoveredAddress = normalizers_1.addressNormalizer(recoveredAddress);
        /*
         * Add the `0x` prefix to the current address
         */
        const normalizedCurrentAddress = normalizers_1.addressNormalizer(currentAddress);
        return resolve(normalizedRecoveredAddress === normalizedCurrentAddress);
    }
    catch (caughtError) {
        return reject(caughtError);
    }
};
/**
 * Verify a signed message. Useful for verifying identity. (In conjunction with `signMessage`)
 *
 * @method verifyMessage
 *
 * @param {string} message The message to verify if it was signed correctly
 * @param {string} signature The message signature as a `hex` string (you usually get this via `signMessage`)
 * @param {string} currentAddress The current selected address (in the UI)
 *
 * All the above params are sent in as props of an object.
 *
 * @return {Promise<boolean>} A boolean to indicate if the message/signature pair are valid (wrapped inside a `Promise`)
 */
exports.verifyMessage = (_a = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var { currentAddress } = _a, messageVerificationObject = __rest(_a, ["currentAddress"]);
    /*
     * Validate the current address
     */
    validators_1.addressValidator(currentAddress);
    /*
     * Validate the rest of the pros using the core helper
     */
    const { message, signature } = helpers_1.messageVerificationObjectValidator(messageVerificationObject);
    /*
     * We must check for the Metamask injected in-page proxy every time we
     * try to access it. This is because something can change it from the time
     * of last detection until now.
     */
    return helpers_2.methodCaller(
    /*
     * @TODO Move into own (non-anonymous) method
     * This way we could better test it
     */
    () => new Promise((resolve, reject) => {
        /*
         * Verify the message
         */
        methodLinks_1.verifyMessage(message, 
        /*
         * Ensure the signature has the `0x` prefix
         */
        normalizers_1.hexSequenceNormalizer(signature), exports.verifyMessageCallback(currentAddress, resolve, reject));
    }), messages_1.staticMethods.cannotSignMessage);
});
