"use strict";
/* @flow */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_1 = __importDefault(require("web3"));
const utils_1 = require("../purser-core/utils");
const class_1 = __importDefault(require("./class"));
const helpers_1 = require("./helpers");
const messages_1 = require("./messages");
/**
 * Open the Metamask Wallet instance
 *
 * @method open
 *
 * @return {WalletType} The wallet object resulted by instantiating the class
 * (Object is wrapped in a promise).
 */
exports.open = () => __awaiter(void 0, void 0, void 0, function* () {
    let addressAfterEnable;
    try {
        /*
         * We're on the Modern Metamask (after EIP-1102)
         * See: https://eips.ethereum.org/EIPS/eip-1102
         */
        var anyGlobal = global;
        if (anyGlobal.ethereum) {
            /*
             * Inject the web3 provider
             */
            anyGlobal.web3 = new web3_1.default(anyGlobal.ethereum);
            /*
             * Enable it
             */
            [addressAfterEnable] = yield anyGlobal.ethereum.enable();
        }
        /*
         * We're on the legacy version of Metamask
         */
        if (!anyGlobal.ethereum && anyGlobal.web3) {
            /*
             * Warn the user about legacy mode
             *
             * @TODO Remove legacy metmask version messages
             * After an adequate amount of time has passed
             */
            utils_1.warning(messages_1.staticMethods.legacyMode);
            /*
             * Enable it
             *
             * @NOTE There's an argument to be made here that it's dangerous to use
             * the `getInpageProvider()` helper before using `detect()`
             */
            const legacyProvider = helpers_1.getInpageProvider();
            legacyProvider.enable();
            /*
             * Inject the web3 provider (overwrite the current one)
             */
            anyGlobal.web3 = new web3_1.default(legacyProvider);
        }
        /*
         * Everything functions the same since the Web3 instance is now in place
         * (Granted, it's now using the 1.x.x version)
         */
        return helpers_1.methodCaller(() => {
            const { publicConfigStore: { _state: state }, } = helpers_1.getInpageProvider();
            return new class_1.default({
                /*
                 * The EIP-1102 mode uses the address we got after enabling (and getting
                 * the users's permission), while the legacy mode get the address from
                 * the state
                 */
                address: addressAfterEnable || state.selectedAddress,
            });
        }, messages_1.staticMethods.metamaskNotAvailable);
    }
    catch (caughtError) {
        /*
         * User did not authorize us to open his account. We cannot do anything else.
         * (By clicking the 'Reject' button on the API request popup)
         */
        throw new Error(messages_1.staticMethods.didNotAuthorize);
    }
});
/**
 * Check if Metamask's injected web3 proxy instance is available in the
 * global object.
 *
 * Makes use of the `detect()` helper, basically it's a wrapper
 * that exposes it from the module.
 *
 * @method detect
 *
 * @return {boolean} Only returns true if it's available, otherwise it will throw.
 */
exports.detect = () => __awaiter(void 0, void 0, void 0, function* () { return helpers_1.detect(); });
/**
 * Hook into Metamask's state events observers array to be able to act on account
 * changes from the UI
 *
 * It's a wrapper around the `setStateEventObserver()` helper method
 *
 * @method accountChangeHook
 *
 * @param {Function} callback Function to add the state events update array
 * It receives the state object as an only argument
 *
 * @return {Promise<void>} Does not return noting
 */
exports.accountChangeHook = (callback) => __awaiter(void 0, void 0, void 0, function* () {
    /*
     * If detect fails, it will throw, with a message explaining the problem
     * (Most likely Metamask will be locked, so we won't be able to get to
     * the state observer via the in-page provider)
     */
    helpers_1.detect();
    try {
        return helpers_1.setStateEventObserver(callback);
    }
    catch (error) {
        /*
         * If this throws/catches here it means something very weird is going on.
         * `detect()` should catch anything that're directly related to Metamask's functionality,
         * but if that passes and we have to catch it here, it means some underlying APIs
         * might have changed, and this will be very hard to debug
         */
        throw new Error(messages_1.staticMethods.cannotAddHook);
    }
});
/*
 * @NOTE There's an argument to be made here to expose the new version
 */
const metamaskWallet = {
    open: exports.open,
    detect: exports.detect,
    accountChangeHook: exports.accountChangeHook,
};
exports.default = metamaskWallet;
