"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_isequal_1 = __importDefault(require("lodash.isequal"));
const utils_1 = require("../purser-core/utils");
const helpers_1 = require("../purser-core/helpers");
const validators_1 = require("../purser-core/validators");
const normalizers_1 = require("../purser-core/normalizers");
const defaults_1 = require("../purser-core/defaults");
const types_1 = require("../purser-core/types");
const staticMethods_1 = require("./staticMethods");
const helpers_2 = require("./helpers");
const validators_2 = require("./validators");
const methodLinks_1 = require("./methodLinks");
const defaults_2 = require("./defaults");
const messages_1 = require("./messages");
const { SETTERS, GETTERS, GENERIC_PROPS, WALLET_PROPS } = defaults_1.DESCRIPTORS;
/*
 * "Private" (internal) variable(s).
 */
let state = {};
let internalPublicKey;
class MetamaskWallet {
    constructor({ address }) {
        /*
         * Validate the address that's coming in from Metamask
         */
        validators_1.addressValidator(address);
        Object.defineProperties(this, {
            /*
             * The initial address is set when `open()`-ing the wallet, but after that
             * it's updated via the Metamask state change observer.
             *
             * This way, we keep it in sync with the changes from Metamask's UI
             */
            address: Object.assign({}, { value: address }, SETTERS),
            type: Object.assign({}, { value: types_1.TYPE_SOFTWARE }, GENERIC_PROPS),
            subtype: Object.assign({}, { value: types_1.SUBTYPE_METAMASK }, GENERIC_PROPS),
            sign: Object.assign({}, {
                value: (transactionObject) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: transactionObject,
                    });
                    return staticMethods_1.signTransaction(Object.assign({}, transactionObject, { from: this.address }));
                }),
            }, WALLET_PROPS),
            signMessage: Object.assign({}, {
                value: (messageObject = {}) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: messageObject,
                        requiredOr: defaults_1.REQUIRED_PROPS.SIGN_MESSAGE,
                    });
                    return staticMethods_1.signMessage({
                        currentAddress: this.address,
                        message: messageObject.message,
                        messageData: messageObject.messageData,
                    });
                }),
            }, WALLET_PROPS),
            verifyMessage: Object.assign({}, {
                value: (messageVerificationObject) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: messageVerificationObject,
                        requiredAll: defaults_1.REQUIRED_PROPS.VERIFY_MESSAGE,
                    });
                    return staticMethods_1.verifyMessage(Object.assign({ currentAddress: this.address }, messageVerificationObject));
                }),
            }, WALLET_PROPS),
        });
        /*
         * We must check for the Metamask injected in-page proxy every time we
         * try to access it. This is because something can change it from the time
         * of last detection until now.
         *
         * So we must ensure, again, that we have a state update event to hook
         * our update method onto.
         */
        helpers_2.methodCaller(
        /*
         * @TODO Move into own (non-anonymous) method
         * This way we could better test it
         *
         * Set the state change observer
         *
         * This tracks updates Metamask's states and updates the local address
         * value if that changes in the UI
         */
        () => helpers_2.setStateEventObserver(
        /*
         * @TODO Move into own (non-anonymous) method
         * This way we could better test it
         */
        (newState) => {
            try {
                /*
                 * Validate the state object that's coming in.
                 * It should have all the props needed for us to work with.
                 *
                 * If they aren't there, it means that either Metamask is locked,
                 * or somebody tampered with them.
                 */
                validators_2.validateMetamaskState(newState);
                /*
                 * We only update the values if the state has changed.
                 * (We're using lodash here to deep compare the two state objects)
                 */
                if (!lodash_isequal_1.default(state, newState)) {
                    state = newState;
                    this.address = newState.selectedAddress;
                    /*
                     * Reset the saved public key, as the address now changed
                     */
                    internalPublicKey = undefined;
                    return true;
                }
                return false;
            }
            catch (caughtError) {
                /*
                 * We don't want to throw or stop execution, so in the case that the
                 * state doesn't validate, and update and silently return `false`.
                 */
                return false;
            }
        }), messages_1.MetamaskWallet.cannotObserve);
    }
    /*
     * Public Key Getter
     */
    /* eslint-disable-next-line class-methods-use-this */
    get publicKey() {
        /*
         * We can't memoize the getter (as we do in most other such getters)
         *
         * This is because the address could change at any time leaving us with a
         * stale value for the public key, as there is no way (currently) to invalidate
         * this value.
         */
        if (internalPublicKey) {
            return Promise.resolve(internalPublicKey);
        }
        return MetamaskWallet.recoverPublicKey(this.address);
    }
    /**
     * Recover the public key from a signed message.
     * Sign a message, and use that signature to recover the (R), (S) signature
     * components, along with the reco(V)ery param. We then use those values to
     * recover, set internally, and return the public key.
     *
     * @method recoverPublicKey
     *
     * @param {string} currentAddress The current selected address.
     * Note the we don't need to validate this here since it comes from a trusted
     * source: the class constructor.
     *
     * @return {Promise} The recovered public key (for the currently selected addresss)
     */
    static recoverPublicKey(currentAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            /*
             * We must check for the Metamask injected in-page proxy every time we
             * try to access it. This is because something can change it from the time
             * of last detection until now.
             */
            return helpers_2.methodCaller(
            /*
             * @TODO Move into own (non-anonymous) method
             * This way we could better test it
             */
            () => new Promise(resolve => {
                /*
                 * Sign the message. This will prompt the user via Metamask's UI
                 */
                methodLinks_1.signMessage(
                /*
                 * Ensure the hex string has the `0x` prefix
                 */
                normalizers_1.hexSequenceNormalizer(
                /*
                 * We could really do with default Flow types for Buffer...
                 */
                /* $FlowFixMe */
                Buffer.from(defaults_2.PUBLICKEY_RECOVERY_MESSAGE).toString(defaults_1.HEX_HASH_TYPE)), currentAddress, 
                /*
                 * @TODO Move into own (non-anonymous) method
                 * This way we could better test it
                 */
                (error, signature) => {
                    try {
                        /*
                         * Validate that the signature is in the correct format
                         */
                        validators_1.hexSequenceValidator(signature);
                        const recoveredPublicKey = helpers_1.recoverPublicKey({
                            message: defaults_2.PUBLICKEY_RECOVERY_MESSAGE,
                            signature,
                        });
                        /*
                         * Add the `0x` prefix to the recovered public key
                         */
                        const normalizedPublicKey = normalizers_1.hexSequenceNormalizer(recoveredPublicKey);
                        /*
                         * Also set the internal public key
                         */
                        internalPublicKey = normalizedPublicKey;
                        return resolve(normalizedPublicKey);
                    }
                    catch (caughtError) {
                        /*
                         * Don't throw an Error if the user just cancels signing the message.
                         * This is normal UX, not an exception
                         */
                        if (error.message.includes(defaults_2.STD_ERRORS.CANCEL_MSG_SIGN)) {
                            return utils_1.warning(messages_1.staticMethods.cancelMessageSign);
                        }
                        throw new Error(error.message);
                    }
                });
            }), messages_1.MetamaskWallet.cannotGetPublicKey);
        });
    }
}
exports.default = MetamaskWallet;
/*
 * We need to use `defineProperties` to make props enumerable.
 * When adding them via a `Class` getter/setter it will prevent that by default
 */
Object.defineProperties(MetamaskWallet.prototype, {
    publicKey: GETTERS,
});
