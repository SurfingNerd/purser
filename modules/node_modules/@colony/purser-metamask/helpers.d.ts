import { MetamaskInpageProviderType, MetamaskStateEventsObserverType } from './types';
/**
 * Detect the Metmask Extensaion
 *
 * @method detect
 *
 * @return {boolean} If it's available it will return true, otherwise it will throw
 */
export declare const detect: () => Promise<boolean>;
/**
 * Helper method that wraps a method passed as an argument and first checks
 * for Metamask's availablity before calling it.
 *
 * This is basically a wrapper, so that we can cut down on code repetition, since
 * this pattern repeats itself every time we try to access the in-page proxy.
 *
 * @method methodCaller
 *
 * @param {Function} callback The method to call, if Metamask is available
 * @param {string} errorMessage Optional error message to show to use
 * (in case Metamask is not available)
 *
 * @return {any} It returns the result of the callback execution
 */
export declare const methodCaller: (callback: () => any, errorMessage?: string) => Promise<any>;
/**
 * If the Metamask injected instance is available, get the in-page provider
 *
 * @method getInpageProvider
 *
 * @return {Object} The `MetamaskInpageProvider` object instance
 */
export declare const getInpageProvider: () => MetamaskInpageProviderType;
/**
 * Add a new observer method to Metamask's state update events
 *
 * @method setStateEventObserver
 *
 * @param {Function} observer Function to add the state events update array
 *
 * @return {number} the length of the state events update array
 */
export declare const setStateEventObserver: (observer: MetamaskStateEventsObserverType) => void;
declare const metamaskHelpers: {
    detect: () => Promise<boolean>;
    methodCaller: (callback: () => any, errorMessage?: string) => Promise<any>;
    getInpageProvider: () => MetamaskInpageProviderType;
    setStateEventObserver: (observer: MetamaskStateEventsObserverType) => void;
};
export default metamaskHelpers;
