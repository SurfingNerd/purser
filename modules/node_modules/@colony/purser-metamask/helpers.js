"use strict";
/* @flow */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = require("./messages");
/*
 * @TODO Add isModern() helper method to detect the new version of Metamask
 */
/**
 * Detect the Metmask Extensaion
 *
 * @method detect
 *
 * @return {boolean} If it's available it will return true, otherwise it will throw
 */
exports.detect = () => __awaiter(void 0, void 0, void 0, function* () {
    /*
     * Modern Metamask Version
     */
    var anyGlobal = global;
    if (anyGlobal.ethereum) {
        /*
         * @NOTE This is a temporary failsafe check, since Metmask is running an
         * intermediate version which, while it contains most of the `ethereum`
         * global object, it doesn't contain this helper method
         *
         * @TODO Remove legacy metmask object availability check
         * After an adequate amount of time has passed
         */
        if (anyGlobal.ethereum.isUnlocked && !(yield anyGlobal.ethereum.isUnlocked())) {
            throw new Error(messages_1.helpers.isLocked);
        }
        /*
         * @NOTE This is a temporary failsafe check, since Metmask is running an
         * intermediate version which, while it contains most of the `ethereum`
         * global object, it doesn't contain this helper method
         *
         * @TODO Remove legacy metmask object availability check
         * After an adequate amount of time has passed
         */
        if (anyGlobal.ethereum.isEnabled && !(yield anyGlobal.ethereum.isEnabled())) {
            throw new Error(messages_1.helpers.notEnabled);
        }
        /*
         * @NOTE If the `isUnlocked` and the `isEnabled` methods are not available
         * it means we are running the pre-release version of Metamask, just prior
         * to the EIP-1102 update, so we just ignore those checks
         */
        return true;
    }
    /*
     * Legacy Metamask Version
     */
    if (!anyGlobal.ethereum && anyGlobal.web3) {
        if (!anyGlobal.web3.currentProvider ||
            !anyGlobal.web3.currentProvider.publicConfigStore) {
            throw new Error(messages_1.helpers.noInpageProvider);
        }
        /* eslint-disable-next-line no-underscore-dangle */
        if (!anyGlobal.web3.currentProvider.publicConfigStore._state) {
            throw new Error(messages_1.helpers.noProviderState);
        }
        /* eslint-disable-next-line no-underscore-dangle */
        if (!anyGlobal.web3.currentProvider.publicConfigStore._state.selectedAddress) {
            throw new Error(messages_1.helpers.notEnabled);
        }
        return true;
    }
    throw new Error(messages_1.helpers.noExtension);
});
/**
 * Helper method that wraps a method passed as an argument and first checks
 * for Metamask's availablity before calling it.
 *
 * This is basically a wrapper, so that we can cut down on code repetition, since
 * this pattern repeats itself every time we try to access the in-page proxy.
 *
 * @method methodCaller
 *
 * @param {Function} callback The method to call, if Metamask is available
 * @param {string} errorMessage Optional error message to show to use
 * (in case Metamask is not available)
 *
 * @return {any} It returns the result of the callback execution
 */
exports.methodCaller = (callback, errorMessage = '') => __awaiter(void 0, void 0, void 0, function* () {
    try {
        /*
         * Detect if the Metamask injected proxy is (still) available
         *
         * We need this little go-around trick to mock just one export of
         * the module, while leaving the rest of the module intact so we can test it
         *
         * See: https://github.com/facebook/jest/issues/936
         */
        /* eslint-disable-next-line no-use-before-define */
        yield metamaskHelpers.detect();
        return callback();
    }
    catch (caughtError) {
        throw new Error(`${errorMessage}${errorMessage ? ' ' : ''}Error: ${caughtError.message}`);
    }
});
/**
 * If the Metamask injected instance is available, get the in-page provider
 *
 * @method getInpageProvider
 *
 * @return {Object} The `MetamaskInpageProvider` object instance
 */
exports.getInpageProvider = () => {
    /*
     * We need this little go-around trick to mock just one export of
     * the module, while leaving the rest of the module intact so we can test it
     *
     * See: https://github.com/facebook/jest/issues/936
     */
    var anyGlobal = global;
    if (anyGlobal.ethereum) {
        return anyGlobal.ethereum;
    }
    return anyGlobal.web3.currentProvider;
};
/**
 * Add a new observer method to Metamask's state update events
 *
 * @method setStateEventObserver
 *
 * @param {Function} observer Function to add the state events update array
 *
 * @return {number} the length of the state events update array
 */
exports.setStateEventObserver = (observer) => {
    const { publicConfigStore: { _events: stateEvents }, } = 
    /*
     * We need this little go-around trick to mock just one export of
     * the module, while leaving the rest of the module intact so we can test it
     *
     * See: https://github.com/facebook/jest/issues/936
     */
    /* eslint-disable-next-line no-use-before-define */
    metamaskHelpers.getInpageProvider();
    return stateEvents.update.push(observer);
};
/*
 * This default export is only here to help us with testing, otherwise
 * it wound't be needed
 */
const metamaskHelpers = {
    detect: exports.detect,
    methodCaller: exports.methodCaller,
    getInpageProvider: exports.getInpageProvider,
    setStateEventObserver: exports.setStateEventObserver,
};
exports.default = metamaskHelpers;
