"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const genericWallet_1 = __importDefault(require("../purser-core/genericWallet"));
const helpers_1 = require("../purser-core/helpers");
const defaults_1 = require("../purser-core/defaults");
const types_1 = require("../purser-core/types");
const staticMethods_1 = require("./staticMethods");
const { WALLET_PROPS } = defaults_1.DESCRIPTORS;
class LedgerWallet extends genericWallet_1.default {
    constructor(propObject) {
        super(propObject);
        Object.defineProperties(this, {
            /*
             * Set the actual type and subtype (overwrite the generic ones)
             */
            type: Object.assign({}, { value: types_1.TYPE_HARDWARE }, WALLET_PROPS),
            subtype: Object.assign({}, { value: types_1.SUBTYPE_LEDGER }, WALLET_PROPS),
            sign: Object.assign({}, {
                value: (transactionObject) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: transactionObject,
                    });
                    const { chainId = this.chainId } = transactionObject || {};
                    return staticMethods_1.signTransaction(Object.assign({}, transactionObject, {
                        derivationPath: yield this.derivationPath,
                        chainId,
                    }));
                }),
            }, WALLET_PROPS),
            signMessage: Object.assign({}, {
                value: (messageObject) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: messageObject,
                        requiredOr: defaults_1.REQUIRED_PROPS.SIGN_MESSAGE,
                    });
                    return staticMethods_1.signMessage({
                        derivationPath: yield this.derivationPath,
                        message: messageObject.message,
                        messageData: messageObject.messageData,
                    });
                }),
            }, WALLET_PROPS),
            verifyMessage: Object.assign({}, {
                value: (signatureVerificationObject) => __awaiter(this, void 0, void 0, function* () {
                    /*
                     * Validate the trasaction's object input
                     */
                    helpers_1.userInputValidator({
                        firstArgument: signatureVerificationObject,
                        requiredAll: defaults_1.REQUIRED_PROPS.VERIFY_MESSAGE,
                    });
                    const { message, signature } = signatureVerificationObject;
                    return staticMethods_1.verifyMessage({
                        publicKey: yield this.publicKey,
                        message,
                        signature,
                    });
                }),
            }, WALLET_PROPS),
        });
    }
}
exports.default = LedgerWallet;
