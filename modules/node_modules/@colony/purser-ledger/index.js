"use strict";
/* @flow */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../purser-core/helpers");
const defaults_1 = require("../purser-core/defaults");
const class_1 = __importDefault(require("./class"));
const helpers_2 = require("./helpers");
const messages_1 = require("./messages");
/**
 * Open a new wallet from the public key and chain code, which are received
 * form the Ledger device (after unlocking it and entering the Ethereum app)
 *
 * @method open
 *
 * @param {number} addressCount the number of extra addresses to generate from the derivation path
 * @param {number} chainId The id of the network to use, defaults to mainnet (1)
 *
 * The above param is sent in as a prop of an {WalletArgumentsType} object.
 *
 * @return {WalletType} The wallet object resulted by instantiating the class
 * (Object is wrapped in a promise).
 *
 */
exports.open = (argumentObject = {}) => __awaiter(void 0, void 0, void 0, function* () {
    /*
     * Validate the trasaction's object input
     */
    helpers_1.userInputValidator({
        firstArgument: argumentObject,
    });
    const { addressCount, chainId = defaults_1.CHAIN_IDS.HOMESTEAD } = argumentObject;
    /*
     * @TODO Reduce code repetition
     * By moving this inside a helper. This same patter will be used on the
     * trezor wallet as well.
     *
     * If we're on a testnet set the coin type id to `1`
     * This will be used in the derivation path
     */
    const coinType = chainId === defaults_1.CHAIN_IDS.HOMESTEAD ? defaults_1.PATH.COIN_MAINNET : defaults_1.PATH.COIN_TESTNET;
    /*
     * Get to root derivation path based on the coin type.
     *
     * Based on this, we will then derive all the needed address indexes
     * (inside the class constructor)
     */
    const rootDerivationPath = helpers_1.derivationPathSerializer({
        coinType,
    });
    try {
        const ledger = yield helpers_2.ledgerConnection();
        /*
         * Get the harware wallet's root public key and chain code, to use
         * for deriving the rest of the accounts
         */
        const { publicKey, chainCode } = yield ledger.getAddress(
        /*
         * @NOTE Ledger requires a derivation path containing only the account value
         * No change and index
         *
         * If you want to prompt the user on the device, set the second argument
         * as true.
         */
        rootDerivationPath, false, true);
        const walletInstance = new class_1.default({
            publicKey,
            chainCode,
            /*
             * Since we need to strip out the change values when opening the Ledger
             * wallet, we need to remove the post-pending slash. This way, the final
             * derivation path gets concatenated correctly.
             *
             * The only alternative would be to re-generate the derivation path inside
             * the class's constructor, but that would mean extra computational resources.
             */
            rootDerivationPath,
            addressCount,
            chainId,
        });
        return walletInstance;
    }
    catch (caughtError) {
        return helpers_2.handleLedgerConnectionError(caughtError, `${messages_1.staticMethods.userExportGenericError}: ${rootDerivationPath} ${caughtError.message}`);
    }
});
const ledgerWallet = {
    open: exports.open,
};
exports.default = ledgerWallet;
