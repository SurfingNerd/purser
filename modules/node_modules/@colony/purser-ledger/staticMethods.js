"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_tx_1 = require("ethereumjs-tx");
const validators_1 = require("../purser-core/validators");
const normalizers_1 = require("../purser-core/normalizers");
const utils_1 = require("../purser-core/utils");
const helpers_1 = require("../purser-core/helpers");
const defaults_1 = require("../purser-core/defaults");
const helpers_2 = require("./helpers");
const messages_1 = require("./messages");
/**
 * Sign a transaction object and return the serialized signature (as a hex string)
 *
 * @method signTransaction
 *
 * @param {string} derivationPath the derivation path for the account with which to sign the transaction (provided by the Wallet instance)
 * @param {bigNumber} gasPrice gas price for the transaction in WEI (as an instance of bigNumber), defaults to 9000000000 (9 GWEI)
 * @param {bigNumber} gasLimit gas limit for the transaction (as an instance of bigNumber), defaults to 21000
 * @param {number} chainId the id of the chain for which this transaction is intended
 * @param {number} nonce the nonce to use for the transaction (as a number)
 * @param {string} to the address to which to the transaction is sent
 * @param {bigNumber} value the value of the transaction in WEI (as an instance of bigNumber), defaults to 1
 * @param {string} inputData data appended to the transaction (as a `hex` string)
 *
 * All the above params are sent in as props of an {TransactionObjectType} object.
 *
 * @return {Promise<string>} the hex signature string
 */
exports.signTransaction = (obj) => __awaiter(void 0, void 0, void 0, function* () {
    const transactionObject = {
        chainId: obj.chainId,
        gasPrice: obj.gasPrice,
        gasLimit: obj.gasLimit,
        nonce: obj.nonce,
        value: obj.value,
        inputData: obj.inputData,
        to: obj.to
    };
    const { gasPrice, gasLimit, chainId, nonce, to, value, inputData, } = helpers_1.transactionObjectValidator(transactionObject);
    try {
        const ledger = yield helpers_2.ledgerConnection();
        const derivationPath = obj.derivationPath;
        validators_1.derivationPathValidator(derivationPath);
        /*
         * Ledger needs the unsigned "raw" transaction hex, which it will sign and
         * return the (R) and (S) signature components alog with the reco(V)ery param.
         *
         *
         * See fundamentals of Elliptic Curve Digital Signature Algorithm (ECDSA) to
         * get an general idea of where the three components come from:
         * https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm
         *
         * Also, see EIP-155 for the 27 and 28 magic numbers expected in the recovery
         * parameter:
         * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md
         */
        const unsignedTransaction = new ethereumjs_tx_1.Transaction(Object.assign({}, {
            gasPrice: normalizers_1.hexSequenceNormalizer(normalizers_1.multipleOfTwoHexValueNormalizer(gasPrice)),
            gasLimit: normalizers_1.hexSequenceNormalizer(normalizers_1.multipleOfTwoHexValueNormalizer(gasLimit)),
            /*
             * Nonces needs to be sent in as a hex string, and to be padded as a multiple of two.
             * Eg: '3' to be '03', `12c` to be `012c`
             */
            nonce: normalizers_1.hexSequenceNormalizer(normalizers_1.multipleOfTwoHexValueNormalizer(nonce.toString(16))),
            value: normalizers_1.hexSequenceNormalizer(normalizers_1.multipleOfTwoHexValueNormalizer(value)),
            data: normalizers_1.hexSequenceNormalizer(inputData),
            /*
             * The transaction object needs to be seeded with the (R) and (S) signature components with
             * empty data, and the Reco(V)ery param as the chain id (all, im hex string format).
             *
             * See this issue for context:
             * https://github.com/LedgerHQ/ledgerjs/issues/43
             */
            r: normalizers_1.hexSequenceNormalizer(normalizers_1.multipleOfTwoHexValueNormalizer(String(defaults_1.SIGNATURE.R))),
            s: normalizers_1.hexSequenceNormalizer(normalizers_1.multipleOfTwoHexValueNormalizer(String(defaults_1.SIGNATURE.S))),
            v: normalizers_1.hexSequenceNormalizer(
            /*
             * @TODO Add `bigNumber` `toHexString` wrapper method
             *
             * Flow confuses bigNumber's `toString` with the String object
             * prototype `toString` method
             */
            /* $FlowFixMe */
            normalizers_1.multipleOfTwoHexValueNormalizer(chainId.toString(16))),
        }, to ? { to: normalizers_1.addressNormalizer(to) } : {}), helpers_1.getChainDefinition(chainId));
        /*
         * Sign the transaction object via your Ledger Wallet
         *
         * We also warn the user here, since the device will need confirmation, but only in dev mode.
         */
        utils_1.warning(messages_1.staticMethods.userSignInteractionWarning);
        const { r: rSignatureComponent, s: sSignatureComponent, v: recoveryParameter, } = yield ledger.signTransaction(normalizers_1.derivationPathNormalizer(derivationPath), unsignedTransaction.serialize().toString(defaults_1.HEX_HASH_TYPE));
        /*
         * Proving that we signed the above transaction.
         *
         * @NOTE We need to modify the original transaction
         * Otherwise EthereumTx will complain because internally it checks for the valid instance
         */
        unsignedTransaction.r = Buffer.from(normalizers_1.hexSequenceNormalizer(rSignatureComponent), defaults_1.HEX_HASH_TYPE);
        unsignedTransaction.s = Buffer.from(normalizers_1.hexSequenceNormalizer(sSignatureComponent), defaults_1.HEX_HASH_TYPE);
        unsignedTransaction.v = Buffer.from(normalizers_1.hexSequenceNormalizer(recoveryParameter), defaults_1.HEX_HASH_TYPE);
        const serializedSignedTransaction = unsignedTransaction
            .serialize()
            .toString(defaults_1.HEX_HASH_TYPE);
        /*
         * Add the hex prefix
         */
        return normalizers_1.hexSequenceNormalizer(serializedSignedTransaction);
    }
    catch (caughtError) {
        return helpers_2.handleLedgerConnectionError(caughtError, `${messages_1.staticMethods.userSignTxGenericError}: ${utils_1.objectToErrorString(transactionObject)} ${caughtError.message}`);
    }
});
/**
 * Sign a message and return the signature. Useful for verifying identities.
 *
 * @method signMessage
 *
 * @param {string} derivationPath the derivation path for the account with which to sign the message
 * @param {string} message the message you want to sign
 *
 * All the above params are sent in as props of an {object}.
 *
 * @return {Promise<string>} The signed message `hex` string (wrapped inside a `Promise`)
 */
exports.signMessage = (obj) => __awaiter(void 0, void 0, void 0, function* () {
    if (obj === null || typeof obj !== 'object') {
        throw new Error(messages_1.staticMethods.signMessageArgumentMissing);
    }
    const { derivationPath, message, messageData } = obj;
    /*
     * Validate input values: derivationPath and message
     */
    validators_1.derivationPathValidator(derivationPath);
    const toSign = helpers_1.messageOrDataValidator({ message, messageData });
    try {
        const ledger = yield helpers_2.ledgerConnection();
        /*
         * Sign the message object via your Ledger Wallet
         *
         * We also warn the user here, since the device will need confirmation, but only in dev mode.
         */
        utils_1.warning(messages_1.staticMethods.userSignMessageInteractionWarning);
        const { r: rSignatureComponent, s: sSignatureComponent, v: recoveryParameter, } = yield ledger.signPersonalMessage(normalizers_1.derivationPathNormalizer(derivationPath), 
        /*
         * The message needs to be sent in as an hex string
         *
         * Also, Flow don't know about Buffer
         */
        /* $FlowFixMe */
        Buffer.from(toSign).toString(defaults_1.HEX_HASH_TYPE));
        /*
         * Combine the (R), and (S) signature components, alogn with the reco(V)ery param (that
         * gets converted into `hex`)
         */
        return normalizers_1.hexSequenceNormalizer(`${rSignatureComponent}` +
            `${sSignatureComponent}` +
            `${recoveryParameter.toString(16)}`);
    }
    catch (caughtError) {
        return helpers_2.handleLedgerConnectionError(caughtError, `${messages_1.staticMethods.userSignTxGenericError}: message: (${toSign.toString()}) ${caughtError.message}`);
    }
});
/**
 * Verify a signed message. Useful for verifying identity. (In conjunction with `signMessage`)
 *
 * @method verifyMessage
 *
 * @param {string} publicKey The public key to verify the signature against (this is coming from the wallet instance)
 * @param {string} message The message to verify if it was signed correctly
 * @param {string} signature The message signature as a `hex` string (you usually get this via `signMessage`)
 *
 * All the above params are sent in as props of an {MessageVerificationObjectType} object.
 *
 * @return {Promise<boolean>} A boolean to indicate if the message/signature pair are valid (wrapped inside a `Promise`)
 */
exports.verifyMessage = (obj) => __awaiter(void 0, void 0, void 0, function* () {
    const { publicKey } = obj;
    /*
     * Validate the public key locally
     */
    validators_1.hexSequenceValidator(publicKey);
    const signatureMessage = { message: obj.message, signature: obj.signature };
    /*
     * Validate the rest of the pros using the core helper
     */
    const { message, signature } = helpers_1.messageVerificationObjectValidator(signatureMessage);
    return helpers_1.verifyMessageSignature({
        /*
         * Ensure the public key has the hex `0x` prefix
         */
        publicKey: normalizers_1.hexSequenceNormalizer(publicKey),
        message,
        /*
         * Ensure the signature has the hex `0x` prefix
         */
        signature: normalizers_1.hexSequenceNormalizer(signature),
    });
});
